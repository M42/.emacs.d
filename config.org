#+Title: config.org
#+Author: Mario Román
#+Email: mromang08@gmail.com
#+TODO: DISABLED WIP | DONE

This is my Emacs init file, written in org-mode using literate
programming and =org-babel= blocks. The =init.el= file tangles the
Elisp code blocks of this file into =config.el=. I have taken ideas
for my configuration mainly from

  - [[http://cestlaz.github.io/][C'est la Z]]
  - [[https://github.com/hrs/dotfiles/blob/master/emacs.d/configuration.org][Harry R. Schwartz's configuration file]]

and from many other configuration files and blogs such as

  - [[http://emacsredux.com/][Emacs Redux]]
  - [[http://irreal.org/blog/][Irreal]]
  - [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's configuration file]]
  - [[http://karl-voit.at/2017/06/03/emacs-org/][Karl Voit's configuration file]]

It /works for me/ on Emacs 26.0.50 and org-version 9.0.9. You can check
your Emacs version with =M-x version= and your org-mode version with
=M-x org-version=.

* Basic
** Personal information
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/User-Identification.html][User information]] used by Emacs in frame titles and email.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Mario Román"
      user-mail-address "mromang08@gmail.com")
#+END_SRC

Sensitive information is stored into a different file which I do not
upload to GitHub. It sets some variables.

#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/emacs.secrets" t)
#+END_SRC

** Files
A list of the most important files on my workflow. Those variables are
used all across the configuration file; and listing them here eases
the process of rewriting directory paths.

#+BEGIN_SRC emacs-lisp
  (setq m42/math-file       (expand-file-name "~/Dropbox/orgzly/Math.org"))
  (setq m42/init-file       (expand-file-name "~/.emacs.d/config.org"))
  (setq m42/agenda-file     (expand-file-name "~/Dropbox/orgzly/Tasks.org"))
  (setq m42/journal-file     (expand-file-name "~/Dropbox/orgzly/Journal.org"))
  (setq m42/archive-file    (expand-file-name "~/Dropbox/orgzly/Archive.org"))
  (setq m42/org-folder      (expand-file-name "~/Dropbox/orgzly"))

  (global-set-key (kbd "<f7>") (lambda() (interactive) (find-file m42/math-file)))
  (global-set-key (kbd "<f8>") (lambda() (interactive) (find-file m42/init-file)))
  (global-set-key (kbd "<f9>") (lambda() (interactive) (find-file m42/agenda-file)))
#+END_SRC

** Local bin
Includes the local bin on the =exec-path=. This allows Emacs to find
executables in the local binaries folder.

#+BEGIN_SRC emacs-lisp
(setq exec-path (cons "/home/mario/.local/bin" exec-path))
#+END_SRC

** Initial buffer
Inhibits the startup screen and loads an initial buffer.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
(setq initial-buffer-choice m42/agenda-file)
#+END_SRC

** Reload init.el
The configuration files can be reloaded at any time using =M-insert=.
This eases the process of writing, debugging and testing the
configuration file. Current set variables will not be removed; and
Emacs will need a complete restart to clean them.

#+BEGIN_SRC emacs-lisp
(global-set-key [M-insert] 
  '(lambda() (interactive) (load-file "~/.emacs.d/init.el"))
  )
#+END_SRC

** Restart emacs
[[https://github.com/iqbalansari/restart-emacs][Restart-emacs]] is a package to restart Emacs from within Emacs. It
offers the command =restart-emacs=, which kills the current Emacs
session and starts a new session.

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :ensure t)
#+END_SRC

** Better defaults
#+BEGIN_SRC emacs-lisp
(use-package better-defaults
  :ensure t)
#+END_SRC

Really open large files.

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold nil)
#+END_SRC

** Backup files
Disables backup files.

#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
#+END_SRC

** Shell
Starts shell using =C-c s=.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c s") 'eshell)
#+END_SRC

** Multiple cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         )
)
#+END_SRC

** Visual-regexp
#+BEGIN_SRC emacs-lisp
(use-package visual-regexp
  :ensure t
  :bind (
    ("C-c C-r" . vr/replace)
    ("C-c q" . vr/query-replace)
    ("C-c m" . vr/mc-mark)
    ))
#+END_SRC
** Autorevert
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode 1)
#+END_SRC
** Setting emacs window title
#+BEGIN_SRC emacs-lisp
(setq frame-title-format "%f")
#+END_SRC
** Helpful
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :ensure t)
#+END_SRC

* Navigation
** Smex
[[https://www.emacswiki.org/emacs/Smex][Smex]] provides an enhancement to the =M-x= command. Uses =ido= for
autocompletion and provides a convenient interface to the most
frequently used commands.

#+BEGIN_SRC emacs-lisp
(use-package smex
  :ensure t
  :config (smex-initialize)
  :bind (("M-x" . smex)))
#+END_SRC

** Switching windows with ctrl+tab
It is possible to change windows in Emacs using =C-x o=, but
sometimes =C-tab= still feels more intuitive to me.

#+BEGIN_SRC emacs-lisp
(global-set-key [C-tab] 'other-window)
(global-set-key [C-iso-lefttab]
  (lambda ()
    (interactive)
    (other-window -1)))
#+END_SRC

** Swiper
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  )

(use-package swiper
  :ensure t
  :config
  (progn
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (global-set-key (kbd "C-M-s") 'swiper)
    (global-set-key (kbd "C-c r") 'ivy-resume)
    ;(global-set-key (kbd "<f6>") 'ivy-resume)
    (global-set-key (kbd "M-x") 'counsel-M-x)
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (global-set-key (kbd "<f1> f") 'counsel-describe-function)
    (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
    (global-set-key (kbd "<f1> l") 'counsel-load-library)
    (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
    (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
    (global-set-key (kbd "C-c g") 'counsel-git)
    (global-set-key (kbd "C-c j") 'counsel-git-grep)
    (global-set-key (kbd "C-c k") 'counsel-ag)
    (global-set-key (kbd "C-x l") 'counsel-locate)
    (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
    (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
    ))
#+END_SRC

** Smartparens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t)
;; (require 'smartparens-config)
#+END_SRC
** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind ("C-:" . avy-goto-char)
)
#+END_SRC
** Anzu
#+BEGIN_SRC emacs-lisp
(use-package anzu
  :ensure t
  :init
    (anzu-mode +1)
    (global-anzu-mode +1)
  :config
    (setq anzu-cons-mode-line-p nil))
#+END_SRC
** Pdf-tools
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :config
    (pdf-tools-install))
#+END_SRC
** Winmove
#+BEGIN_SRC emacs-lisp
(use-package windmove
  ;; :defer 4
  :ensure t
  :config
  ;; use command key on Mac
  (windmove-default-keybindings 'super)
  ;; wrap around at edges
  (setq windmove-wrap-around t))

;; Make windmove work in org-mode:
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)
#+END_SRC

** openwith
#+BEGIN_SRC emacs-lisp
;(use-package crux
;  :ensure t
;  :bind (("C-c o" . crux-open-with))
;  )
#+END_SRC
** beacon
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :config (beacon-mode 1))
#+END_SRC

** CUA rectangle mode
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x <SPC>") 'cua-rectangle-mark-mode)
#+END_SRC
** Following links
#+BEGIN_SRC emacs-lisp
(use-package goto-addr
  :hook ((compilation-mode . goto-address-mode)
         (prog-mode . goto-address-prog-mode)
         (eshell-mode . goto-address-mode)
         (shell-mode . goto-address-mode))
  :bind (:map goto-address-highlight-keymap
              ("<RET>" . goto-address-at-point)
              ("M-<RET>" . newline))
  :commands (goto-address-prog-mode
             goto-address-mode))
#+END_SRC
* Programming
** Flycheck
Flycheck checks the syntax of programming languages.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))
#+END_SRC
** Polymode
#+BEGIN_SRC emacs-lisp
  (use-package polymode
    :ensure t)
#+END_SRC
** Magit
[[https://magit.vc/][Magit]] is an interface to the version control system [[https://git-scm.com/][Git]]. The main
function is =magit-status=, which shows the status of the files on the
current repository.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-c g" . magit-status)
    )
#+END_SRC

** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config
  (projectile-global-mode)
(setq projectile-completion-system 'ivy))

;(use-package counsel-projectile
;  :ensure t
;  :config (counsel-projectile-on)
;)
#+END_SRC

** Haskell
Allows interactive Haskell evaluation in Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode :ensure t)
  (require 'haskell-interactive-mode)
  (require 'haskell-process)
  (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
  (setq haskell-process-type 'cabal-repl)
  (setq-default flycheck-disabled-checkers '(haskell-ghc))
#+END_SRC

*** Intero
#+BEGIN_SRC emacs-lisp
(use-package flycheck-haskell :ensure t)
(use-package intero :ensure t)
(add-hook 'haskell-mode-hook 'intero-mode)

(with-eval-after-load 'intero
  (with-eval-after-load 'flycheck 
    (flycheck-add-next-checker 'intero '(warning . haskell-hlint))))
#+END_SRC

*** Hindent
**** hindent.el
#+BEGIN_SRC emacs-lisp
;;; hindent.el --- Indent haskell code using the "hindent" program

;; Copyright (c) 2014 Chris Done. All rights reserved.

;; Author: Chris Done <chrisdone@gmail.com>
;; URL: https://github.com/chrisdone/hindent
;; Package-Requires: ((cl-lib "0.5"))

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Provides a minor mode and commands for easily using the "hindent"
;; program to reformat Haskell code.

;; Add `hindent-mode' to your `haskell-mode-hook' and use the provided
;; keybindings as needed.  Set `hindent-reformat-buffer-on-save' to
;; `t' globally or in local variables to have your code automatically
;; reformatted.

;;; Code:

(require 'cl-lib)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Customization properties

(defgroup hindent nil
  "Integration with the \"hindent\" reformatting program."
  :prefix "hindent-"
  :group 'haskell)

(defcustom hindent-style
  nil
  "The style to use for formatting.

For hindent versions lower than 5, you must set this to a non-nil string."
  :group 'hindent
  :type 'string
  :safe #'stringp)

(make-obsolete-variable 'hindent-style nil "hindent 5")


(defcustom hindent-process-path
  "hindent"
  "Location where the hindent executable is located."
  :group 'hindent
  :type 'string
  :safe #'stringp)

(defcustom hindent-reformat-buffer-on-save nil
  "Set to t to run `hindent-reformat-buffer' when a buffer in `hindent-mode' is saved."
  :group 'hindent
  :type 'boolean
  :safe #'booleanp)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Minor mode

(defvar hindent-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map [remap indent-region] #'hindent-reformat-region)
    (define-key map [remap fill-paragraph] #'hindent-reformat-decl-or-fill)
    map)
  "Keymap for `hindent-mode'.")

;;;###autoload
(define-minor-mode hindent-mode
  "Indent code with the hindent program.

Provide the following keybindings:

\\{hindent-mode-map}"
  :init-value nil
  :keymap hindent-mode-map
  :lighter " HI"
  :group 'hindent
  :require 'hindent
  (if hindent-mode
      (add-hook 'before-save-hook 'hindent--before-save nil t)
    (remove-hook 'before-save-hook 'hindent--before-save t)))

(defun hindent--before-save ()
  "Optionally reformat the buffer on save."
  (when hindent-reformat-buffer-on-save
    (hindent-reformat-buffer)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Interactive functions

;;;###autoload
(defun hindent-reformat-decl ()
  "Re-format the current declaration.

The declaration is parsed and pretty printed.  Comments are
preserved, although placement may be funky."
  (interactive)
  (let ((start-end (hindent-decl-points)))
    (when start-end
      (let ((beg (car start-end))
            (end (cdr start-end)))
        (hindent-reformat-region beg end t)))))

;;;###autoload
(defun hindent-reformat-buffer ()
  "Reformat the whole buffer."
  (interactive)
  (hindent-reformat-region (point-min)
                           (point-max)))

;;;###autoload
(defun hindent-reformat-decl-or-fill (justify)
  "Re-format current declaration, or fill paragraph.

Fill paragraph if in a comment, otherwise reformat the current
declaration.  When filling, the prefix argument JUSTIFY will
cause the text to be justified, as per `fill-paragraph'."
  (interactive (progn
                 ;; Copied from `fill-paragraph'
                 (barf-if-buffer-read-only)
                 (list (if current-prefix-arg 'full))))
  (if (hindent-in-comment)
      (fill-paragraph justify t)
    (hindent-reformat-decl)))

;;;###autoload
(defun hindent-reformat-region (beg end &optional drop-newline)
  "Reformat the region from BEG to END, accounting for indentation.

If DROP-NEWLINE is non-nil, don't require a newline at the end of
the file."
  (interactive "r")
  (if (= (save-excursion (goto-char beg)
                         (line-beginning-position))
         beg)
      (hindent-reformat-region-as-is beg end drop-newline)
    (let* ((column (- beg (line-beginning-position)))
           (string (buffer-substring-no-properties beg end))
           (new-string (with-temp-buffer
                         (insert (make-string column ? ) string)
                         (hindent-reformat-region-as-is (point-min)
                                                        (point-max)
                                                        drop-newline)
                         (delete-region (point-min) (1+ column))
                         (buffer-substring (point-min)
                                           (point-max)))))
      (save-excursion
        (goto-char beg)
        (delete-region beg end)
        (insert new-string)))))

;;;###autoload
(define-obsolete-function-alias 'hindent/reformat-decl 'hindent-reformat-decl)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Internal library

(defun hindent-reformat-region-as-is (beg end &optional drop-newline)
  "Reformat the given region from BEG to END as-is.

This is the place where hindent is actually called.

If DROP-NEWLINE is non-nil, don't require a newline at the end of
the file."
  (let* ((original (current-buffer))
         (orig-str (buffer-substring-no-properties beg end)))
    (with-temp-buffer
      (let ((temp (current-buffer)))
        (with-current-buffer original
          (let ((ret (apply #'call-process-region
                            (append (list beg
                                          end
                                          hindent-process-path
                                          nil ; delete
                                          temp ; output
                                          nil)
                                    (hindent-extra-arguments)))))
            (cond
             ((= ret 1)
              (let ((error-string
                     (with-current-buffer temp
                       (let ((string (progn (goto-char (point-min))
                                            (buffer-substring (line-beginning-position)
                                                              (line-end-position)))))
                         string))))
                (if (string= error-string "hindent: Parse error: EOF")
                    (message "language pragma")
                  (error error-string))))
             ((= ret 0)
              (let* ((last-decl (= end (point-max)))
                     (new-str (with-current-buffer temp
                                (when (and drop-newline (not last-decl))
                                  (goto-char (point-max))
                                  (when (looking-back "\n" (1- (point)))
                                    (delete-char -1)))
                                (buffer-string))))
                (if (not (string= new-str orig-str))
                    (let ((line (line-number-at-pos))
                          (col (current-column)))
                      (delete-region beg
                                     end)
                      (let ((new-start (point)))
                        (insert new-str)
                        (let ((new-end (point)))
                          (goto-char (point-min))
                          (forward-line (1- line))
                          (goto-char (+ (line-beginning-position) col))
                          (when (looking-back "^[ ]+" (line-beginning-position))
                            (back-to-indentation))
                          (delete-trailing-whitespace new-start new-end)))
                      (message "Formatted."))
                  (message "Already formatted.")))))))))))

(defun hindent-decl-points ()
  "Get the start and end position of the current declaration.

This assumes that declarations start at column zero and that the
rest is always indented by one space afterwards, so Template
Haskell uses with it all being at column zero are not expected to
work."
  (cond
   ;; If we're in a block comment spanning multiple lines then let's
   ;; see if it starts at the beginning of the line (or if any comment
   ;; is at the beginning of the line, we don't care to treat it as a
   ;; proper declaration.
   ((and (hindent-in-comment)
         (save-excursion (goto-char (line-beginning-position))
                         (hindent-in-comment)))
    nil)
   ((save-excursion
      (goto-char (line-beginning-position))
      (or (looking-at "^-}$")
          (looking-at "^{-$")))
    nil)
   ;; Otherwise we just do our line-based hack.
   (t
    (save-excursion
      (let ((start
             (or (cl-letf
                     (((symbol-function 'jump)
                       #'(lambda ()
                           (search-backward-regexp "^[^ \n]" nil t 1)
                           (cond
                            ((save-excursion (goto-char (line-beginning-position))
                                             (looking-at "|]"))
                             (jump))
                            (t (unless (or (looking-at "^-}$")
                                           (looking-at "^{-$"))
                                 (point)))))))
                   (goto-char (line-end-position))
                   (jump))
                 0))
            (end
             (progn
               (goto-char (1+ (point)))
               (or (cl-letf
                       (((symbol-function 'jump)
                         #'(lambda ()
                             (when (search-forward-regexp "[\n]+[^ \n]" nil t 1)
                               (cond
                                ((save-excursion (goto-char (line-beginning-position))
                                                 (looking-at "|]"))
                                 (jump))
                                (t (forward-char -1)
                                   (search-backward-regexp "[^\n ]" nil t)
                                   (forward-char)
                                   (point)))))))
                     (jump))
                   (point-max)))))
        (cons start end))))))

(defun hindent-in-comment ()
  "Are we currently in a comment?"
  (save-excursion
    (when (and (= (line-end-position)
                  (point))
               (/= (line-beginning-position) (point)))
      (forward-char -1))
    (and
     (elt (syntax-ppss) 4)
     ;; Pragmas {-# SPECIALIZE .. #-} etc are not to be treated as
     ;; comments, even though they are highlighted as such
     (not (save-excursion (goto-char (line-beginning-position))
                          (looking-at "{-# "))))))

(defun hindent-extra-arguments ()
  "Extra command line arguments for the hindent invocation."
  (append
   (when (boundp 'haskell-language-extensions)
     haskell-language-extensions)
   (when hindent-style
     (list "--style" hindent-style))))

(provide 'hindent)

;;; hindent.el ends here
#+END_SRC
**** Hook
#+BEGIN_SRC emacs-lisp
(add-hook 'haskell-mode-hook #'hindent-mode)
#+END_SRC
** Markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t)
#+END_SRC

** R
Emacs Speaks Statistics.

#+BEGIN_SRC emacs-lisp
(use-package ess
  :ensure t)

(require 'ess-site)
#+END_SRC

** DISABLED Python
Elpy support.

#+BEGIN_SRC emacs-lisp
  ;; (use-package elpy
  ;;   :ensure t)
  ;; (elpy-enable)
  ;; (elpy-use-ipython)
  ;; (setq elpy-rpc-python-command "python2")
#+END_SRC

*** Jupyter notebook
#+BEGIN_SRC emacs-lisp
(use-package ein
  :ensure t)
#+END_SRC

** Agda
Loads the =agda-mode= configuration. Agda provides the location
of its configuration file with the command =agda-mode locate=.

#+BEGIN_SRC emacs-lisp
(load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "agda-mode locate")))
#+END_SRC

*** Customization
Little tweak on agda colors. Original blue was too dark.

#+BEGIN_SRC emacs-lisp
  (add-hook 'agda2-mode-hook
    (lambda ()
      (set-face-attribute 'agda2-highlight-record-face nil
        :foreground "light steel blue")))
  (add-hook 'agda2-mode-hook
    (lambda ()
      (set-face-attribute 'agda2-highlight-postulate-face nil
        :foreground "light steel blue")))
  (add-hook 'agda2-mode-hook
    (lambda ()
      (set-face-attribute 'agda2-highlight-primitive-face nil
        :foreground "light steel blue")))
#+END_SRC

** Idris
#+BEGIN_SRC emacs-lisp
(use-package idris-mode
  :ensure t)
#+END_SRC
** Sage
#+BEGIN_SRC emacs-lisp
  (use-package sage-shell-mode
    :ensure t)

  (setq sage-shell:use-prompt-toolkit t)
#+END_SRC

** Lisp
Evaluates Lisp in place with `C-c e`. Taken from [[http://emacsredux.com/blog/2013/06/21/eval-and-replace/][Emacs Redux]].

#+BEGIN_SRC emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))
  (global-set-key (kbd "C-c e") 'eval-and-replace)
#+END_SRC

** Latex
#+BEGIN_SRC emacs-lisp
  (use-package tex
    :ensure auctex)

  (add-hook 'LaTeX-mode-hook (lambda () (local-set-key (kbd "C-ñ") #'preview-buffer)))

  ;; (add-hook 'LaTeX-mode-hook
  ;; 	(lambda () (set (make-variable-buffer-local 'TeX-electric-math)
  ;; 			(cons "$" "$"))))

  (add-hook 'LaTeX-mode-hook
          '(lambda ()
            (define-key LaTeX-mode-map (kbd "$") 'self-insert-command)))
#+END_SRC

*** Pdf generation process
#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
	'("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
    "bibtex %b"
    "makeindex %b"
    "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
    "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

*** Fontify-titles
#+BEGIN_SRC emacs-lisp
  (setq font-latex-fontify-sectioning 'color)
  (setq font-latex-fontify-sectioning 1.0)
  (setq font-latex-slide-title-face 1.0)
  (setq font-latex-fontify-script nil)
  (fset 'tex-font-lock-suscript 'ignore)

  ; (set-face-attribute 'font-latex-sectioning-1-face nil 
  ;    :weight 'bold
  ;    :height 1.0)

  ;(set-face-attribute 'font-latex-sectioning-2-face nil 
  ;   :weight 'bold
  ;   :height 1.0)

  ;(set-face-attribute 'font-latex-sectioning-3-face nil 
  ;   :weight 'bold
  ;   :height 1.0)
#+END_SRC
** Dot
#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
  :ensure t)
(setq default-tab-width 4)
#+END_SRC

** Proof General
Loads the Proof General file. Proof General can be installed directly
from AUR.

#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/lisp/PG/generic/proof-site")
#+END_SRC

#+RESULTS:
: t

*** Electric terminator
#+BEGIN_SRC emacs-lisp
(setq proof-electric-terminator-enable t)
#+END_SRC

** Coq
*** Company-coq

*** Agda input
#+BEGIN_SRC emacs-lisp
;;; agda-input.el --- The Agda input method

;;; Commentary:

;; A highly customisable input method which can inherit from other
;; Quail input methods. By default the input method is geared towards
;; the input of mathematical and other symbols in Agda programs.
;;
;; Use M-x customize-group agda-input to customise this input method.
;; Note that the functions defined under "Functions used to tweak
;; translation pairs" below can be used to tweak both the key
;; translations inherited from other input methods as well as the
;; ones added specifically for this one.
;;
;; Use agda-input-show-translations to see all the characters which
;; can be typed using this input method (except for those
;; corresponding to ASCII characters).

;;; Code:

(require 'quail)
(require 'cl)
;; Quail is quite stateful, so be careful when editing this code.  Note
;; that with-temp-buffer is used below whenever buffer-local state is
;; modified.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utility functions

(defun agda-input-concat-map (f xs)
  "Concat (map F XS)."
  (apply 'append (mapcar f xs)))

(defun agda-input-to-string-list (s)
  "Convert a string S to a list of one-character strings, after
removing all space and newline characters."
  (agda-input-concat-map
   (lambda (c) (if (member c (string-to-list " \n"))
              nil
            (list (string c))))
   (string-to-list s)))

(defun agda-input-character-range (from to)
  "A string consisting of the characters from FROM to TO."
  (let (seq)
    (dotimes (i (1+ (- to from)))
      (setq seq (cons (+ from i) seq)))
    (concat (nreverse seq))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions used to tweak translation pairs

;; lexical-let is used since Elisp lacks lexical scoping.

(defun agda-input-compose (f g)
  "\x -> concatMap F (G x)"
  (lexical-let ((f1 f) (g1 g))
    (lambda (x) (agda-input-concat-map f1 (funcall g1 x)))))

(defun agda-input-or (f g)
  "\x -> F x ++ G x"
  (lexical-let ((f1 f) (g1 g))
    (lambda (x) (append (funcall f1 x) (funcall g1 x)))))

(defun agda-input-nonempty ()
  "Only keep pairs with a non-empty first component."
  (lambda (x) (if (> (length (car x)) 0) (list x))))

(defun agda-input-prepend (prefix)
  "Prepend PREFIX to all key sequences."
  (lexical-let ((prefix1 prefix))
    (lambda (x) `((,(concat prefix1 (car x)) . ,(cdr x))))))

(defun agda-input-prefix (prefix)
  "Only keep pairs whose key sequence starts with PREFIX."
  (lexical-let ((prefix1 prefix))
    (lambda (x)
      (if (equal (substring (car x) 0 (length prefix1)) prefix1)
          (list x)))))

(defun agda-input-suffix (suffix)
  "Only keep pairs whose key sequence ends with SUFFIX."
  (lexical-let ((suffix1 suffix))
    (lambda (x)
      (if (equal (substring (car x)
                            (- (length (car x)) (length suffix1)))
                 suffix1)
          (list x)))))

(defun agda-input-drop (ss)
  "Drop pairs matching one of the given key sequences.
SS should be a list of strings."
  (lexical-let ((ss1 ss))
    (lambda (x) (unless (member (car x) ss1) (list x)))))

(defun agda-input-drop-beginning (n)
  "Drop N characters from the beginning of each key sequence."
  (lexical-let ((n1 n))
    (lambda (x) `((,(substring (car x) n1) . ,(cdr x))))))

(defun agda-input-drop-end (n)
  "Drop N characters from the end of each key sequence."
  (lexical-let ((n1 n))
    (lambda (x)
      `((,(substring (car x) 0 (- (length (car x)) n1)) .
         ,(cdr x))))))

(defun agda-input-drop-prefix (prefix)
  "Only keep pairs whose key sequence starts with PREFIX.
This prefix is dropped."
  (agda-input-compose
   (agda-input-drop-beginning (length prefix))
   (agda-input-prefix prefix)))

(defun agda-input-drop-suffix (suffix)
  "Only keep pairs whose key sequence ends with SUFFIX.
This suffix is dropped."
  (lexical-let ((suffix1 suffix))
    (agda-input-compose
     (agda-input-drop-end (length suffix1))
     (agda-input-suffix suffix1))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Customization

;; The :set keyword is set to 'agda-input-incorporate-changed-setting
;; so that the input method gets updated immediately when users
;; customize it. However, the setup functions cannot be run before all
;; variables have been defined. Hence the :initialize keyword is set to
;; 'custom-initialize-default to ensure that the setup is not performed
;; until agda-input-setup is called at the end of this file.

(defgroup agda-input nil
  "The Agda input method.
After tweaking these settings you may want to inspect the resulting
translations using `agda-input-show-translations'."
  :group 'agda2
  :group 'leim)

(defcustom agda-input-tweak-all
  '(agda-input-compose
    (agda-input-prepend "\\")
    (agda-input-nonempty))
  "An expression yielding a function which can be used to tweak
all translations before they are included in the input method.
The resulting function (if non-nil) is applied to every
\(KEY-SEQUENCE . TRANSLATION) pair and should return a list of such
pairs. (Note that the translations can be anything accepted by
`quail-defrule'.)
If you change this setting manually (without using the
customization buffer) you need to call `agda-input-setup' in
order for the change to take effect."
  :group 'agda-input
  :set 'agda-input-incorporate-changed-setting
  :initialize 'custom-initialize-default
  :type 'sexp)

(defcustom agda-input-inherit
  `(("TeX" . (agda-input-compose
              (agda-input-drop '("geq" "leq" "bullet" "qed" "par"))
              (agda-input-or
               (agda-input-drop-prefix "\\")
               (agda-input-or
                (agda-input-compose
                 (agda-input-drop '("^l" "^o" "^r" "^v"))
                 (agda-input-prefix "^"))
                (agda-input-prefix "_")))))
    )
  "A list of Quail input methods whose translations should be
inherited by the Agda input method (with the exception of
translations corresponding to ASCII characters).
The list consists of pairs (qp . tweak), where qp is the name of
a Quail package, and tweak is an expression of the same kind as
`agda-input-tweak-all' which is used to tweak the translation
pairs of the input method.
The inherited translation pairs are added last, after
`agda-input-user-translations' and `agda-input-translations'.
If you change this setting manually (without using the
customization buffer) you need to call `agda-input-setup' in
order for the change to take effect."
  :group 'agda-input
  :set 'agda-input-incorporate-changed-setting
  :initialize 'custom-initialize-default
  :type '(repeat (cons (string :tag "Quail package")
                       (sexp :tag "Tweaking function"))))

(defcustom agda-input-translations
  (let ((max-lisp-eval-depth 2800)) `(

  ;; Equality and similar symbols.

  ("eq"  . ,(agda-input-to-string-list "=∼∽≈≋∻∾∿≀≃⋍≂≅ ≌≊≡≣≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≍≎≏≬⋕"))
  ("eqn" . ,(agda-input-to-string-list "≠≁ ≉     ≄  ≇≆  ≢                 ≭    "))

                    ("=n"  . ("≠"))
  ("~"    . ("∼"))  ("~n"  . ("≁"))
  ("~~"   . ("≈"))  ("~~n" . ("≉"))
  ("~~~"  . ("≋"))
  (":~"   . ("∻"))
  ("~-"   . ("≃"))  ("~-n" . ("≄"))
  ("-~"   . ("≂"))
  ("~="   . ("≅"))  ("~=n" . ("≇"))
  ("~~-"  . ("≊"))
  ("=="   . ("≡"))  ("==n" . ("≢"))
  ("==="  . ("≣"))
  (".="   . ("≐"))  (".=." . ("≑"))
  (":="   . ("≔"))  ("=:"  . ("≕"))
  ("=o"   . ("≗"))
  ("(="   . ("≘"))
  ("and=" . ("≙"))  ("or=" . ("≚"))
  ("*="   . ("≛"))
  ("t="   . ("≜"))
  ("def=" . ("≝"))
  ("m="   . ("≞"))
  ("?="   . ("≟"))

  ;; Inequality and similar symbols.

  ("leq"  . ,(agda-input-to-string-list "<≪⋘≤≦≲ ≶≺≼≾⊂⊆ ⋐⊏⊑ ⊰⊲⊴⋖⋚⋜⋞"))
  ("leqn" . ,(agda-input-to-string-list "≮  ≰≨≴⋦≸⊀ ⋨⊄⊈⊊  ⋢⋤ ⋪⋬   ⋠"))
  ("geq"  . ,(agda-input-to-string-list ">≫⋙≥≧≳ ≷≻≽≿⊃⊇ ⋑⊐⊒ ⊱⊳⊵⋗⋛⋝⋟"))
  ("geqn" . ,(agda-input-to-string-list "≯  ≱≩≵⋧≹⊁ ⋩⊅⊉⊋  ⋣⋥ ⋫⋭   ⋡"))

  ("<="   . ("≤"))  (">="   . ("≥"))
  ("<=n"  . ("≰"))  (">=n"  . ("≱"))
  ("len"  . ("≰"))  ("gen"  . ("≱"))
  ("<n"   . ("≮"))  (">n"   . ("≯"))
  ("<~"   . ("≲"))  (">~"   . ("≳"))
  ("<~n"  . ("⋦"))  (">~n"  . ("⋧"))
  ("<~nn" . ("≴"))  (">~nn" . ("≵"))

  ("sub"   . ("⊂"))  ("sup"   . ("⊃"))
  ("subn"  . ("⊄"))  ("supn"  . ("⊅"))
  ("sub="  . ("⊆"))  ("sup="  . ("⊇"))
  ("sub=n" . ("⊈"))  ("sup=n" . ("⊉"))

  ("squb"   . ("⊏"))  ("squp"   . ("⊐"))
  ("squb="  . ("⊑"))  ("squp="  . ("⊒"))
  ("squb=n" . ("⋢"))  ("squp=n" . ("⋣"))

  ;; Set membership etc.

  ("member" . ,(agda-input-to-string-list "∈∉∊∋∌∍⋲⋳⋴⋵⋶⋷⋸⋹⋺⋻⋼⋽⋾⋿"))

  ("inn" . ("∉"))
  ("nin" . ("∌"))

  ;; Intersections, unions etc.

  ("intersection" . ,(agda-input-to-string-list "∩⋂∧⋀⋏⨇⊓⨅⋒∏ ⊼      ⨉"))
  ("union"        . ,(agda-input-to-string-list "∪⋃∨⋁⋎⨈⊔⨆⋓∐⨿⊽⊻⊍⨃⊎⨄⊌∑⅀"))

  ("and" . ("∧"))  ("or"  . ("∨"))
  ("And" . ("⋀"))  ("Or"  . ("⋁"))
  ("i"   . ("∩"))  ("un"  . ("∪"))  ("u+" . ("⊎"))  ("u." . ("⊍"))
  ("I"   . ("⋂"))  ("Un"  . ("⋃"))  ("U+" . ("⨄"))  ("U." . ("⨃"))
  ("glb" . ("⊓"))  ("lub" . ("⊔"))
  ("Glb" . ("⨅"))  ("Lub" . ("⨆"))

  ;; Entailment etc.

  ("entails" . ,(agda-input-to-string-list "⊢⊣⊤⊥⊦⊧⊨⊩⊪⊫⊬⊭⊮⊯"))

  ("|-"   . ("⊢"))  ("|-n"  . ("⊬"))
  ("-|"   . ("⊣"))
  ("|="   . ("⊨"))  ("|=n"  . ("⊭"))
  ("||-"  . ("⊩"))  ("||-n" . ("⊮"))
  ("||="  . ("⊫"))  ("||=n" . ("⊯"))
  ("|||-" . ("⊪"))

  ;; Divisibility, parallelity.

  ("|"  . ("∣"))  ("|n"  . ("∤"))
  ("||" . ("∥"))  ("||n" . ("∦"))

  ;; Some symbols from logic and set theory.

  ("all" . ("∀"))
  ("ex"  . ("∃"))
  ("exn" . ("∄"))
  ("0"   . ("∅"))
  ("C"   . ("∁"))

  ;; Corners, ceilings and floors.

  ("c"  . ,(agda-input-to-string-list "⌜⌝⌞⌟⌈⌉⌊⌋"))
  ("cu" . ,(agda-input-to-string-list "⌜⌝  ⌈⌉  "))
  ("cl" . ,(agda-input-to-string-list "  ⌞⌟  ⌊⌋"))

  ("cul" . ("⌜"))  ("cuL" . ("⌈"))
  ("cur" . ("⌝"))  ("cuR" . ("⌉"))
  ("cll" . ("⌞"))  ("clL" . ("⌊"))
  ("clr" . ("⌟"))  ("clR" . ("⌋"))

  ;; Various operators/symbols.

  ("qed"       . ("∎"))
  ("x"         . ("×"))
  ("o"         . ("∘"))
  ("comp"      . ("∘"))
  ("."         . ("∙"))
  ("*"         . ("⋆"))
  (".+"        . ("∔"))
  (".-"        . ("∸"))
  (":"         . ("∶"))
  ("::"        . ("∷"))
  ("::-"       . ("∺"))
  ("-:"        . ("∹"))
  ("+ "        . ("⊹"))
  ("surd3"     . ("∛"))
  ("surd4"     . ("∜"))
  ("increment" . ("∆"))
  ("inf"       . ("∞"))
  ("&"         . ("⅋"))

  ;; Circled operators.

  ("o+"  . ("⊕"))
  ("o--" . ("⊖"))
  ("ox"  . ("⊗"))
  ("o/"  . ("⊘"))
  ("o."  . ("⊙"))
  ("oo"  . ("⊚"))
  ("o*"  . ("⊛"))
  ("o="  . ("⊜"))
  ("o-"  . ("⊝"))

  ("O+"  . ("⨁"))
  ("Ox"  . ("⨂"))
  ("O."  . ("⨀"))
  ("O*"  . ("⍟"))

  ;; Boxed operators.

  ("b+" . ("⊞"))
  ("b-" . ("⊟"))
  ("bx" . ("⊠"))
  ("b." . ("⊡"))

  ;; Various symbols.

  ("integral" . ,(agda-input-to-string-list "∫∬∭∮∯∰∱∲∳"))
  ("angle"    . ,(agda-input-to-string-list "∟∡∢⊾⊿"))
  ("join"     . ,(agda-input-to-string-list "⋈⋉⋊⋋⋌⨝⟕⟖⟗"))

  ;; Arrows.

  ("l"  . ,(agda-input-to-string-list "←⇐⇚⇇⇆↤⇦↞↼↽⇠⇺↜⇽⟵⟸↚⇍⇷ ↹     ↢↩↫⇋⇜⇤⟻⟽⤆↶↺⟲                                     "))
  ("r"  . ,(agda-input-to-string-list "→⇒⇛⇉⇄↦⇨↠⇀⇁⇢⇻↝⇾⟶⟹↛⇏⇸⇶ ↴    ↣↪↬⇌⇝⇥⟼⟾⤇↷↻⟳⇰⇴⟴⟿ ➵➸➙➔➛➜➝➞➟➠➡➢➣➤➧➨➩➪➫➬➭➮➯➱➲➳➺➻➼➽➾⊸"))
  ("u"  . ,(agda-input-to-string-list "↑⇑⟰⇈⇅↥⇧↟↿↾⇡⇞          ↰↱➦ ⇪⇫⇬⇭⇮⇯                                           "))
  ("d"  . ,(agda-input-to-string-list "↓⇓⟱⇊⇵↧⇩↡⇃⇂⇣⇟         ↵↲↳➥ ↯                                                "))
  ("ud" . ,(agda-input-to-string-list "↕⇕   ↨⇳                                                                    "))
  ("lr" . ,(agda-input-to-string-list "↔⇔         ⇼↭⇿⟷⟺↮⇎⇹                                                        "))
  ("ul" . ,(agda-input-to-string-list "↖⇖                        ⇱↸                                               "))
  ("ur" . ,(agda-input-to-string-list "↗⇗                                         ➶➹➚                             "))
  ("dr" . ,(agda-input-to-string-list "↘⇘                        ⇲                ➴➷➘                             "))
  ("dl" . ,(agda-input-to-string-list "↙⇙                                                                         "))

  ("l-"  . ("←"))  ("<-"  . ("←"))  ("l="  . ("⇐"))
  ("r-"  . ("→"))  ("->"  . ("→"))  ("r="  . ("⇒"))  ("=>"  . ("⇒"))
  ("u-"  . ("↑"))                   ("u="  . ("⇑"))
  ("d-"  . ("↓"))                   ("d="  . ("⇓"))
  ("ud-" . ("↕"))                   ("ud=" . ("⇕"))
  ("lr-" . ("↔"))  ("<->" . ("↔"))  ("lr=" . ("⇔"))  ("<=>" . ("⇔"))
  ("ul-" . ("↖"))                   ("ul=" . ("⇖"))
  ("ur-" . ("↗"))                   ("ur=" . ("⇗"))
  ("dr-" . ("↘"))                   ("dr=" . ("⇘"))
  ("dl-" . ("↙"))                   ("dl=" . ("⇙"))

  ("l==" . ("⇚"))  ("l-2" . ("⇇"))                   ("l-r-" . ("⇆"))
  ("r==" . ("⇛"))  ("r-2" . ("⇉"))  ("r-3" . ("⇶"))  ("r-l-" . ("⇄"))
  ("u==" . ("⟰"))  ("u-2" . ("⇈"))                   ("u-d-" . ("⇅"))
  ("d==" . ("⟱"))  ("d-2" . ("⇊"))                   ("d-u-" . ("⇵"))

  ("l--"  . ("⟵"))  ("<--"  . ("⟵"))  ("l~"  . ("↜" "⇜"))
  ("r--"  . ("⟶"))  ("-->"  . ("⟶"))  ("r~"  . ("↝" "⇝" "⟿"))
  ("lr--" . ("⟷"))  ("<-->" . ("⟷"))  ("lr~" . ("↭"))

  ("l-n"  . ("↚"))  ("<-n"  . ("↚"))  ("l=n"  . ("⇍"))
  ("r-n"  . ("↛"))  ("->n"  . ("↛"))  ("r=n"  . ("⇏"))  ("=>n"  . ("⇏"))
  ("lr-n" . ("↮"))  ("<->n" . ("↮"))  ("lr=n" . ("⇎"))  ("<=>n" . ("⇎"))

  ("l-|"  . ("↤"))  ("ll-" . ("↞"))
  ("r-|"  . ("↦"))  ("rr-" . ("↠"))
  ("u-|"  . ("↥"))  ("uu-" . ("↟"))
  ("d-|"  . ("↧"))  ("dd-" . ("↡"))
  ("ud-|" . ("↨"))

  ("l->" . ("↢"))
  ("r->" . ("↣"))

  ("r-o" . ("⊸"))  ("-o"  . ("⊸"))

  ("dz" . ("↯"))

  ;; Ellipsis.

  ("..." . ,(agda-input-to-string-list "⋯⋮⋰⋱"))

  ;; Box-drawing characters.

  ("---" . ,(agda-input-to-string-list "─│┌┐└┘├┤┬┼┴╴╵╶╷╭╮╯╰╱╲╳"))
  ("--=" . ,(agda-input-to-string-list "═║╔╗╚╝╠╣╦╬╩     ╒╕╘╛╞╡╤╪╧ ╓╖╙╜╟╢╥╫╨"))
  ("--_" . ,(agda-input-to-string-list "━┃┏┓┗┛┣┫┳╋┻╸╹╺╻
                                        ┍┯┑┕┷┙┝┿┥┎┰┒┖┸┚┠╂┨┞╀┦┟╁┧┢╈┪┡╇┩
                                        ┮┭┶┵┾┽┲┱┺┹╊╉╆╅╄╃ ╿╽╼╾"))
  ("--." . ,(agda-input-to-string-list "╌╎┄┆┈┊
                                        ╍╏┅┇┉┋"))

  ;; Triangles.

  ;; Big/small, black/white.

  ("t" . ,(agda-input-to-string-list "◂◃◄◅▸▹►▻▴▵▾▿◢◿◣◺◤◸◥◹"))
  ("T" . ,(agda-input-to-string-list "◀◁▶▷▲△▼▽◬◭◮"))

  ("tb" . ,(agda-input-to-string-list "◂▸▴▾◄►◢◣◤◥"))
  ("tw" . ,(agda-input-to-string-list "◃▹▵▿◅▻◿◺◸◹"))

  ("Tb" . ,(agda-input-to-string-list "◀▶▲▼"))
  ("Tw" . ,(agda-input-to-string-list "◁▷△▽"))

  ;; Squares.

  ("sq"  . ,(agda-input-to-string-list "■□◼◻◾◽▣▢▤▥▦▧▨▩◧◨◩◪◫◰◱◲◳"))
  ("sqb" . ,(agda-input-to-string-list "■◼◾"))
  ("sqw" . ,(agda-input-to-string-list "□◻◽"))
  ("sq." . ("▣"))
  ("sqo" . ("▢"))

  ;; Rectangles.

  ("re"  . ,(agda-input-to-string-list "▬▭▮▯"))
  ("reb" . ,(agda-input-to-string-list "▬▮"))
  ("rew" . ,(agda-input-to-string-list "▭▯"))

  ;; Parallelograms.

  ("pa"  . ,(agda-input-to-string-list "▰▱"))
  ("pab" . ("▰"))
  ("paw" . ("▱"))

  ;; Diamonds.

  ("di"  . ,(agda-input-to-string-list "◆◇◈"))
  ("dib" . ("◆"))
  ("diw" . ("◇"))
  ("di." . ("◈"))

  ;; Circles.

  ("ci"   . ,(agda-input-to-string-list "●○◎◌◯◍◐◑◒◓◔◕◖◗◠◡◴◵◶◷⚆⚇⚈⚉"))
  ("cib"  . ("●"))
  ("ciw"  . ("○"))
  ("ci."  . ("◎"))
  ("ci.." . ("◌"))
  ("ciO"  . ("◯"))

  ;; Stars.

  ("st"   . ,(agda-input-to-string-list "⋆✦✧✶✴✹ ★☆✪✫✯✰✵✷✸"))
  ("st4"  . ,(agda-input-to-string-list "✦✧"))
  ("st6"  . ("✶"))
  ("st8"  . ("✴"))
  ("st12" . ("✹"))

  ;; Blackboard bold letters.

  ("bn"   . ("ℕ"))
  ("bz"   . ("ℤ"))
  ("bq"   . ("ℚ"))
  ("br"   . ("ℝ"))
  ("bc"   . ("ℂ"))
  ("bp"   . ("ℙ"))
  ("bb"   . ("𝔹"))
  ("bsum" . ("⅀"))

  ;; Blackboard bold numbers.

  ("b0"   . ("𝟘"))
  ("b1"   . ("𝟙"))
  ("b2"   . ("𝟚"))
  ("b3"   . ("𝟛"))
  ("b4"   . ("𝟜"))
  ("b5"   . ("𝟝"))
  ("b6"   . ("𝟞"))
  ("b7"   . ("𝟟"))
  ("b8"   . ("𝟠"))
  ("b9"   . ("𝟡"))

  ;; Parentheses.

  ("(" . ,(agda-input-to-string-list "([{⁅⁽₍〈⎴⟅⟦⟨⟪⦃〈《「『【〔〖〚︵︷︹︻︽︿﹁﹃﹙﹛﹝（［｛｢"))
  (")" . ,(agda-input-to-string-list ")]}⁆⁾₎〉⎵⟆⟧⟩⟫⦄〉》」』】〕〗〛︶︸︺︼︾﹀﹂﹄﹚﹜﹞）］｝｣"))

  ("[[" . ("⟦"))
  ("]]" . ("⟧"))
  ("<"  . ("⟨"))
  (">"  . ("⟩"))
  ("<<" . ("⟪"))
  (">>" . ("⟫"))
  ("{{" . ("⦃"))
  ("}}" . ("⦄"))

  ("(b" . ("⟅"))
  (")b" . ("⟆"))

  ("lbag" . ("⟅"))
  ("rbag" . ("⟆"))

  ;; Primes.

  ("'" . ,(agda-input-to-string-list "′″‴⁗"))
  ("`" . ,(agda-input-to-string-list "‵‶‷"))

  ;; Fractions.

  ("frac" . ,(agda-input-to-string-list "¼½¾⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞⅟"))

  ;; Bullets.

  ("bu"  . ,(agda-input-to-string-list "•◦‣⁌⁍"))
  ("bub" . ("•"))
  ("buw" . ("◦"))
  ("but" . ("‣"))

  ;; Musical symbols.

  ("note" . ,(agda-input-to-string-list "♩♪♫♬"))
  ("b"    . ("♭"))
  ("#"    . ("♯"))

  ;; Other punctuation and symbols.

  ("\\"         . ("\\"))
  ("en"         . ("–"))
  ("em"         . ("—"))
  ("!!"         . ("‼"))
  ("??"         . ("⁇"))
  ("?!"         . ("‽" "⁈"))
  ("!?"         . ("⁉"))
  ("die"        . ,(agda-input-to-string-list "⚀⚁⚂⚃⚄⚅"))
  ("asterisk"   . ,(agda-input-to-string-list "⁎⁑⁂✢✣✤✥✱✲✳✺✻✼✽❃❉❊❋"))
  ("8<"         . ("✂" "✄"))
  ("tie"        . ("⁀"))
  ("undertie"   . ("‿"))
  ("apl"        . ,(agda-input-to-string-list "⌶⌷⌸⌹⌺⌻⌼⌽⌾⌿⍀⍁⍂⍃⍄⍅⍆⍇⍈
                                               ⍉⍊⍋⍌⍍⍎⍏⍐⍑⍒⍓⍔⍕⍖⍗⍘⍙⍚⍛
                                               ⍜⍝⍞⍟⍠⍡⍢⍣⍤⍥⍦⍧⍨⍩⍪⍫⍬⍭⍮
                                               ⍯⍰⍱⍲⍳⍴⍵⍶⍷⍸⍹⍺⎕"))

  ;; Some combining characters.
  ;;
  ;; The following combining characters also have (other)
  ;; translations:
  ;; ̀ ́ ̂ ̃ ̄ ̆ ̇ ̈ ̋ ̌ ̣ ̧ ̱

  ("^--" . ,(agda-input-to-string-list"̅̿"))
  ("_--" . ,(agda-input-to-string-list"̲̳"))
  ("^~"  . ,(agda-input-to-string-list"̃͌"))
  ("_~"  .  (                         "̰"))
  ("^."  . ,(agda-input-to-string-list"̇̈⃛⃜"))
  ("_."  . ,(agda-input-to-string-list"̣̤"))
  ("^l"  . ,(agda-input-to-string-list"⃖⃐⃔"))
  ("^l-" .  (                         "⃖"))
  ("^r"  . ,(agda-input-to-string-list"⃗⃑⃕"))
  ("^r-" .  (                         "⃗"))
  ("^lr" .  (                         "⃡"))
  ("_lr" .  (                         "͍"))
  ("^^"  . ,(agda-input-to-string-list"̂̑͆"))
  ("_^"  . ,(agda-input-to-string-list"̭̯̪"))
  ("^v"  . ,(agda-input-to-string-list"̌̆"))
  ("_v"  . ,(agda-input-to-string-list"̬̮̺"))

  ;; Shorter forms of many greek letters plus ƛ.

  ("Ga"  . ("α"))  ("GA"  . ("Α"))
  ("Gb"  . ("β"))  ("GB"  . ("Β"))
  ("Gg"  . ("γ"))  ("GG"  . ("Γ"))
  ("Gd"  . ("δ"))  ("GD"  . ("Δ"))
  ("Ge"  . ("ε"))  ("GE"  . ("Ε"))
  ("Gz"  . ("ζ"))  ("GZ"  . ("Ζ"))
  ;; \eta \Eta
  ("Gth" . ("θ"))  ("GTH" . ("Θ"))
  ("Gi"  . ("ι"))  ("GI"  . ("Ι"))
  ("Gk"  . ("κ"))  ("GK"  . ("Κ"))
  ("Gl"  . ("λ"))  ("GL"  . ("Λ"))  ("Gl-" . ("ƛ"))
  ("Gm"  . ("μ"))  ("GM"  . ("Μ"))
  ("Gn"  . ("ν"))  ("GN"  . ("Ν"))
  ("Gx"  . ("ξ"))  ("GX"  . ("Ξ"))
  ;; \omicron \Omicron
  ;; \pi \Pi
  ("Gr"  . ("ρ"))  ("GR"  . ("Ρ"))
  ("Gs"  . ("σ"))  ("GS"  . ("Σ"))
  ("Gt"  . ("τ"))  ("GT"  . ("Τ"))
  ("Gu"  . ("υ"))  ("GU"  . ("Υ"))
  ("Gf"  . ("φ"))  ("GF"  . ("Φ"))
  ("Gc"  . ("χ"))  ("GC"  . ("Χ"))
  ("Gp"  . ("ψ"))  ("GP"  . ("Ψ"))
  ("Go"  . ("ω"))  ("GO"  . ("Ω"))

  ;; Mathematical characters

  ("MiA" . ("𝐴"))
  ("MiB" . ("𝐵"))
  ("MiC" . ("𝐶"))
  ("MiD" . ("𝐷"))
  ("MiE" . ("𝐸"))
  ("MiF" . ("𝐹"))
  ("MiG" . ("𝐺"))
  ("MiH" . ("𝐻"))
  ("MiI" . ("𝐼"))
  ("MiJ" . ("𝐽"))
  ("MiK" . ("𝐾"))
  ("MiL" . ("𝐿"))
  ("MiM" . ("𝑀"))
  ("MiN" . ("𝑁"))
  ("MiO" . ("𝑂"))
  ("MiP" . ("𝑃"))
  ("MiQ" . ("𝑄"))
  ("MiR" . ("𝑅"))
  ("MiS" . ("𝑆"))
  ("MiT" . ("𝑇"))
  ("MiU" . ("𝑈"))
  ("MiV" . ("𝑉"))
  ("MiW" . ("𝑊"))
  ("MiX" . ("𝑋"))
  ("MiY" . ("𝑌"))
  ("MiZ" . ("𝑍"))
  ("Mia" . ("𝑎"))
  ("Mib" . ("𝑏"))
  ("Mic" . ("𝑐"))
  ("Mid" . ("𝑑"))
  ("Mie" . ("𝑒"))
  ("Mif" . ("𝑓"))
  ("Mig" . ("𝑔"))
  ("Mii" . ("𝑖"))
  ("Mij" . ("𝑗"))
  ("Mik" . ("𝑘"))
  ("Mil" . ("𝑙"))
  ("Mim" . ("𝑚"))
  ("Min" . ("𝑛"))
  ("Mio" . ("𝑜"))
  ("Mip" . ("𝑝"))
  ("Miq" . ("𝑞"))
  ("Mir" . ("𝑟"))
  ("Mis" . ("𝑠"))
  ("Mit" . ("𝑡"))
  ("Miu" . ("𝑢"))
  ("Miv" . ("𝑣"))
  ("Miw" . ("𝑤"))
  ("Mix" . ("𝑥"))
  ("Miy" . ("𝑦"))
  ("Miz" . ("𝑧"))
  ("MIA" . ("𝑨"))
  ("MIB" . ("𝑩"))
  ("MIC" . ("𝑪"))
  ("MID" . ("𝑫"))
  ("MIE" . ("𝑬"))
  ("MIF" . ("𝑭"))
  ("MIG" . ("𝑮"))
  ("MIH" . ("𝑯"))
  ("MII" . ("𝑰"))
  ("MIJ" . ("𝑱"))
  ("MIK" . ("𝑲"))
  ("MIL" . ("𝑳"))
  ("MIM" . ("𝑴"))
  ("MIN" . ("𝑵"))
  ("MIO" . ("𝑶"))
  ("MIP" . ("𝑷"))
  ("MIQ" . ("𝑸"))
  ("MIR" . ("𝑹"))
  ("MIS" . ("𝑺"))
  ("MIT" . ("𝑻"))
  ("MIU" . ("𝑼"))
  ("MIV" . ("𝑽"))
  ("MIW" . ("𝑾"))
  ("MIX" . ("𝑿"))
  ("MIY" . ("𝒀"))
  ("MIZ" . ("𝒁"))
  ("MIa" . ("𝒂"))
  ("MIb" . ("𝒃"))
  ("MIc" . ("𝒄"))
  ("MId" . ("𝒅"))
  ("MIe" . ("𝒆"))
  ("MIf" . ("𝒇"))
  ("MIg" . ("𝒈"))
  ("MIh" . ("𝒉"))
  ("MIi" . ("𝒊"))
  ("MIj" . ("𝒋"))
  ("MIk" . ("𝒌"))
  ("MIl" . ("𝒍"))
  ("MIm" . ("𝒎"))
  ("MIn" . ("𝒏"))
  ("MIo" . ("𝒐"))
  ("MIp" . ("𝒑"))
  ("MIq" . ("𝒒"))
  ("MIr" . ("𝒓"))
  ("MIs" . ("𝒔"))
  ("MIt" . ("𝒕"))
  ("MIu" . ("𝒖"))
  ("MIv" . ("𝒗"))
  ("MIw" . ("𝒘"))
  ("MIx" . ("𝒙"))
  ("MIy" . ("𝒚"))
  ("MIz" . ("𝒛"))
  ("McA" . ("𝒜"))
  ("McC" . ("𝒞"))
  ("McD" . ("𝒟"))
  ("McG" . ("𝒢"))
  ("McJ" . ("𝒥"))
  ("McK" . ("𝒦"))
  ("McN" . ("𝒩"))
  ("McO" . ("𝒪"))
  ("McP" . ("𝒫"))
  ("McQ" . ("𝒬"))
  ("McS" . ("𝒮"))
  ("McT" . ("𝒯"))
  ("McU" . ("𝒰"))
  ("McV" . ("𝒱"))
  ("McW" . ("𝒲"))
  ("McX" . ("𝒳"))
  ("McY" . ("𝒴"))
  ("McZ" . ("𝒵"))
  ("Mca" . ("𝒶"))
  ("Mcb" . ("𝒷"))
  ("Mcc" . ("𝒸"))
  ("Mcd" . ("𝒹"))
  ("Mcf" . ("𝒻"))
  ("Mch" . ("𝒽"))
  ("Mci" . ("𝒾"))
  ("Mcj" . ("𝒿"))
  ("Mck" . ("𝓀"))
  ("Mcl" . ("𝓁"))
  ("Mcm" . ("𝓂"))
  ("Mcn" . ("𝓃"))
  ("Mcp" . ("𝓅"))
  ("Mcq" . ("𝓆"))
  ("Mcr" . ("𝓇"))
  ("Mcs" . ("𝓈"))
  ("Mct" . ("𝓉"))
  ("Mcu" . ("𝓊"))
  ("Mcv" . ("𝓋"))
  ("Mcw" . ("𝓌"))
  ("Mcx" . ("𝓍"))
  ("Mcy" . ("𝓎"))
  ("Mcz" . ("𝓏"))
  ("MCA" . ("𝓐"))
  ("MCB" . ("𝓑"))
  ("MCC" . ("𝓒"))
  ("MCD" . ("𝓓"))
  ("MCE" . ("𝓔"))
  ("MCF" . ("𝓕"))
  ("MCG" . ("𝓖"))
  ("MCH" . ("𝓗"))
  ("MCI" . ("𝓘"))
  ("MCJ" . ("𝓙"))
  ("MCK" . ("𝓚"))
  ("MCL" . ("𝓛"))
  ("MCM" . ("𝓜"))
  ("MCN" . ("𝓝"))
  ("MCO" . ("𝓞"))
  ("MCP" . ("𝓟"))
  ("MCQ" . ("𝓠"))
  ("MCR" . ("𝓡"))
  ("MCS" . ("𝓢"))
  ("MCT" . ("𝓣"))
  ("MCU" . ("𝓤"))
  ("MCV" . ("𝓥"))
  ("MCW" . ("𝓦"))
  ("MCX" . ("𝓧"))
  ("MCY" . ("𝓨"))
  ("MCZ" . ("𝓩"))
  ("MCa" . ("𝓪"))
  ("MCb" . ("𝓫"))
  ("MCc" . ("𝓬"))
  ("MCd" . ("𝓭"))
  ("MCe" . ("𝓮"))
  ("MCf" . ("𝓯"))
  ("MCg" . ("𝓰"))
  ("MCh" . ("𝓱"))
  ("MCi" . ("𝓲"))
  ("MCj" . ("𝓳"))
  ("MCk" . ("𝓴"))
  ("MCl" . ("𝓵"))
  ("MCm" . ("𝓶"))
  ("MCn" . ("𝓷"))
  ("MCo" . ("𝓸"))
  ("MCp" . ("𝓹"))
  ("MCq" . ("𝓺"))
  ("MCr" . ("𝓻"))
  ("MCs" . ("𝓼"))
  ("MCt" . ("𝓽"))
  ("MCu" . ("𝓾"))
  ("MCv" . ("𝓿"))
  ("MCw" . ("𝔀"))
  ("MCx" . ("𝔁"))
  ("MCy" . ("𝔂"))
  ("MCz" . ("𝔃"))
  ("MfA" . ("𝔄"))
  ("MfB" . ("𝔅"))
  ("MfD" . ("𝔇"))
  ("MfE" . ("𝔈"))
  ("MfF" . ("𝔉"))
  ("MfG" . ("𝔊"))
  ("MfJ" . ("𝔍"))
  ("MfK" . ("𝔎"))
  ("MfL" . ("𝔏"))
  ("MfM" . ("𝔐"))
  ("MfN" . ("𝔑"))
  ("MfO" . ("𝔒"))
  ("MfP" . ("𝔓"))
  ("MfQ" . ("𝔔"))
  ("MfS" . ("𝔖"))
  ("MfT" . ("𝔗"))
  ("MfU" . ("𝔘"))
  ("MfV" . ("𝔙"))
  ("MfW" . ("𝔚"))
  ("MfX" . ("𝔛"))
  ("MfY" . ("𝔜"))
  ("Mfa" . ("𝔞"))
  ("Mfb" . ("𝔟"))
  ("Mfc" . ("𝔠"))
  ("Mfd" . ("𝔡"))
  ("Mfe" . ("𝔢"))
  ("Mff" . ("𝔣"))
  ("Mfg" . ("𝔤"))
  ("Mfh" . ("𝔥"))
  ("Mfi" . ("𝔦"))
  ("Mfj" . ("𝔧"))
  ("Mfk" . ("𝔨"))
  ("Mfl" . ("𝔩"))
  ("Mfm" . ("𝔪"))
  ("Mfn" . ("𝔫"))
  ("Mfo" . ("𝔬"))
  ("Mfp" . ("𝔭"))
  ("Mfq" . ("𝔮"))
  ("Mfr" . ("𝔯"))
  ("Mfs" . ("𝔰"))
  ("Mft" . ("𝔱"))
  ("Mfu" . ("𝔲"))
  ("Mfv" . ("𝔳"))
  ("Mfw" . ("𝔴"))
  ("Mfx" . ("𝔵"))
  ("Mfy" . ("𝔶"))
  ("Mfz" . ("𝔷"))

  ;; (Sub / Super) scripts

  ("_a" . ("ₐ"))
  ("_e" . ("ₑ"))
  ("_h" . ("ₕ"))
  ("_i" . ("ᵢ"))
  ("_j" . ("ⱼ"))
  ("_k" . ("ₖ"))
  ("_l" . ("ₗ"))
  ("_m" . ("ₘ"))
  ("_n" . ("ₙ"))
  ("_o" . ("ₒ"))
  ("_p" . ("ₚ"))
  ("_r" . ("ᵣ"))
  ("_s" . ("ₛ"))
  ("_t" . ("ₜ"))
  ("_u" . ("ᵤ"))
  ("_v" . ("ᵥ"))
  ("_x" . ("ₓ"))

  ("^a" . ("ᵃ"))
  ("^b" . ("ᵇ"))
  ("^c" . ("ᶜ"))
  ("^d" . ("ᵈ"))
  ("^e" . ("ᵉ"))
  ("^f" . ("ᶠ"))
  ("^g" . ("ᵍ"))
  ("^h" . ("ʰ"))
  ("^i" . ("ⁱ"))
  ("^j" . ("ʲ"))
  ("^k" . ("ᵏ"))
  ("^l" . ("ˡ"))
  ("^m" . ("ᵐ"))
  ("^n" . ("ⁿ"))
  ("^o" . ("ᵒ"))
  ("^p" . ("ᵖ"))
  ("^r" . ("ʳ"))
  ("^s" . ("ˢ"))
  ("^t" . ("ᵗ"))
  ("^u" . ("ᵘ"))
  ("^v" . ("ᵛ"))
  ("^w" . ("ʷ"))
  ("^x" . ("ˣ"))
  ("^y" . ("ʸ"))
  ("^z" . ("ᶻ"))

  ("^A" . ("ᴬ"))
  ("^B" . ("ᴮ"))
  ("^D" . ("ᴰ"))
  ("^E" . ("ᴱ"))
  ("^G" . ("ᴳ"))
  ("^H" . ("ᴴ"))
  ("^I" . ("ᴵ"))
  ("^J" . ("ᴶ"))
  ("^K" . ("ᴷ"))
  ("^L" . ("ᴸ"))
  ("^M" . ("ᴹ"))
  ("^N" . ("ᴺ"))
  ("^O" . ("ᴼ"))
  ("^P" . ("ᴾ"))
  ("^R" . ("ᴿ"))
  ("^T" . ("ᵀ"))
  ("^U" . ("ᵁ"))
  ("^V" . ("ⱽ"))
  ("^W" . ("ᵂ"))

  ;; Some ISO8859-1 characters.

  (" "         . (" "))
  ("!"         . ("¡"))
  ("cent"      . ("¢"))
  ("brokenbar" . ("¦"))
  ("degree"    . ("°"))
  ("?"         . ("¿"))
  ("^a_"       . ("ª"))
  ("^o_"       . ("º"))

  ;; Circled, parenthesised etc. numbers and letters.

  ( "(0)" . ,(agda-input-to-string-list " ⓪"))
  ( "(1)" . ,(agda-input-to-string-list "⑴①⒈❶➀➊"))
  ( "(2)" . ,(agda-input-to-string-list "⑵②⒉❷➁➋"))
  ( "(3)" . ,(agda-input-to-string-list "⑶③⒊❸➂➌"))
  ( "(4)" . ,(agda-input-to-string-list "⑷④⒋❹➃➍"))
  ( "(5)" . ,(agda-input-to-string-list "⑸⑤⒌❺➄➎"))
  ( "(6)" . ,(agda-input-to-string-list "⑹⑥⒍❻➅➏"))
  ( "(7)" . ,(agda-input-to-string-list "⑺⑦⒎❼➆➐"))
  ( "(8)" . ,(agda-input-to-string-list "⑻⑧⒏❽➇➑"))
  ( "(9)" . ,(agda-input-to-string-list "⑼⑨⒐❾➈➒"))
  ("(10)" . ,(agda-input-to-string-list "⑽⑩⒑❿➉➓"))
  ("(11)" . ,(agda-input-to-string-list "⑾⑪⒒"))
  ("(12)" . ,(agda-input-to-string-list "⑿⑫⒓"))
  ("(13)" . ,(agda-input-to-string-list "⒀⑬⒔"))
  ("(14)" . ,(agda-input-to-string-list "⒁⑭⒕"))
  ("(15)" . ,(agda-input-to-string-list "⒂⑮⒖"))
  ("(16)" . ,(agda-input-to-string-list "⒃⑯⒗"))
  ("(17)" . ,(agda-input-to-string-list "⒄⑰⒘"))
  ("(18)" . ,(agda-input-to-string-list "⒅⑱⒙"))
  ("(19)" . ,(agda-input-to-string-list "⒆⑲⒚"))
  ("(20)" . ,(agda-input-to-string-list "⒇⑳⒛"))

  ("(a)"  . ,(agda-input-to-string-list "⒜Ⓐⓐ"))
  ("(b)"  . ,(agda-input-to-string-list "⒝Ⓑⓑ"))
  ("(c)"  . ,(agda-input-to-string-list "⒞Ⓒⓒ"))
  ("(d)"  . ,(agda-input-to-string-list "⒟Ⓓⓓ"))
  ("(e)"  . ,(agda-input-to-string-list "⒠Ⓔⓔ"))
  ("(f)"  . ,(agda-input-to-string-list "⒡Ⓕⓕ"))
  ("(g)"  . ,(agda-input-to-string-list "⒢Ⓖⓖ"))
  ("(h)"  . ,(agda-input-to-string-list "⒣Ⓗⓗ"))
  ("(i)"  . ,(agda-input-to-string-list "⒤Ⓘⓘ"))
  ("(j)"  . ,(agda-input-to-string-list "⒥Ⓙⓙ"))
  ("(k)"  . ,(agda-input-to-string-list "⒦Ⓚⓚ"))
  ("(l)"  . ,(agda-input-to-string-list "⒧Ⓛⓛ"))
  ("(m)"  . ,(agda-input-to-string-list "⒨Ⓜⓜ"))
  ("(n)"  . ,(agda-input-to-string-list "⒩Ⓝⓝ"))
  ("(o)"  . ,(agda-input-to-string-list "⒪Ⓞⓞ"))
  ("(p)"  . ,(agda-input-to-string-list "⒫Ⓟⓟ"))
  ("(q)"  . ,(agda-input-to-string-list "⒬Ⓠⓠ"))
  ("(r)"  . ,(agda-input-to-string-list "⒭Ⓡⓡ"))
  ("(s)"  . ,(agda-input-to-string-list "⒮Ⓢⓢ"))
  ("(t)"  . ,(agda-input-to-string-list "⒯Ⓣⓣ"))
  ("(u)"  . ,(agda-input-to-string-list "⒰Ⓤⓤ"))
  ("(v)"  . ,(agda-input-to-string-list "⒱Ⓥⓥ"))
  ("(w)"  . ,(agda-input-to-string-list "⒲Ⓦⓦ"))
  ("(x)"  . ,(agda-input-to-string-list "⒳Ⓧⓧ"))
  ("(y)"  . ,(agda-input-to-string-list "⒴Ⓨⓨ"))
  ("(z)"  . ,(agda-input-to-string-list "⒵Ⓩⓩ"))

  ))
  "A list of translations specific to the Agda input method.
Each element is a pair (KEY-SEQUENCE-STRING . LIST-OF-TRANSLATION-STRINGS).
All the translation strings are possible translations
of the given key sequence; if there is more than one you can choose
between them using the arrow keys.
Note that if you customize this setting you will not
automatically benefit (or suffer) from modifications to its
default value when the library is updated.  If you just want to
add some bindings it is probably a better idea to customize
`agda-input-user-translations'.
These translation pairs are included after those in
`agda-input-user-translations', but before the ones inherited
from other input methods (see `agda-input-inherit').
If you change this setting manually (without using the
customization buffer) you need to call `agda-input-setup' in
order for the change to take effect."
  :group 'agda-input
  :set 'agda-input-incorporate-changed-setting
  :initialize 'custom-initialize-default
  :type '(repeat (cons (string :tag "Key sequence")
                       (repeat :tag "Translations" string))))

(defcustom agda-input-user-translations nil
  "Like `agda-input-translations', but more suitable for user
customizations since by default it is empty.
These translation pairs are included first, before those in
`agda-input-translations' and the ones inherited from other input
methods."
  :group 'agda-input
  :set 'agda-input-incorporate-changed-setting
  :initialize 'custom-initialize-default
  :type '(repeat (cons (string :tag "Key sequence")
                       (repeat :tag "Translations" string))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Inspecting and modifying translation maps

(defun agda-input-get-translations (qp)
  "Return a list containing all translations from the Quail
package QP (except for those corresponding to ASCII).
Each pair in the list has the form (KEY-SEQUENCE . TRANSLATION)."
  (with-temp-buffer
    (activate-input-method qp) ; To make sure that the package is loaded.
    (unless (quail-package qp)
      (error "%s is not a Quail package." qp))
    (let ((decode-map (list 'decode-map)))
      (quail-build-decode-map (list (quail-map)) "" decode-map 0)
      (cdr decode-map))))

(defun agda-input-show-translations (qp)
  "Display all translations used by the Quail package QP (a string).
\(Except for those corresponding to ASCII)."
  (interactive (list (read-input-method-name
                      "Quail input method (default %s): " "Agda")))
  (let ((buf (concat "*" qp " input method translations*")))
    (with-output-to-temp-buffer buf
      (with-current-buffer buf
        (quail-insert-decode-map
         (cons 'decode-map (agda-input-get-translations qp)))))))

(defun agda-input-add-translations (trans)
  "Add the given translations TRANS to the Agda input method.
TRANS is a list of pairs (KEY-SEQUENCE . TRANSLATION). The
translations are appended to the current translations."
  (with-temp-buffer
    (dolist (tr (agda-input-concat-map (eval agda-input-tweak-all) trans))
      (quail-defrule (car tr) (cdr tr) "Agda" t))))

(defun agda-input-inherit-package (qp &optional fun)
  "Let the Agda input method inherit the translations from the
Quail package QP (except for those corresponding to ASCII).
The optional function FUN can be used to modify the translations.
It is given a pair (KEY-SEQUENCE . TRANSLATION) and should return
a list of such pairs."
  (let ((trans (agda-input-get-translations qp)))
    (agda-input-add-translations
     (if fun (agda-input-concat-map fun trans)
       trans))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Setting up the input method

(defun agda-input-setup ()
  "Set up the Agda input method based on the customisable
variables and underlying input methods."

  ;; Create (or reset) the input method.
  (with-temp-buffer
    (quail-define-package "Agda" "UTF-8" "∏" t ; guidance
     "Agda input method.
The purpose of this input method is to edit Agda programs, but
since it is highly customisable it can be made useful for other
tasks as well."
     nil nil nil nil nil nil t ; maximum-shortest
     ))

  (agda-input-add-translations
   (mapcar (lambda (tr) (cons (car tr) (vconcat (cdr tr))))
           (append agda-input-user-translations
                   agda-input-translations)))
  (dolist (def agda-input-inherit)
    (agda-input-inherit-package (car def)
                                (eval (cdr def)))))

(defun agda-input-incorporate-changed-setting (sym val)
  "Update the Agda input method based on the customisable
variables and underlying input methods.
Suitable for use in the :set field of `defcustom'."
  (set-default sym val)
  (agda-input-setup))

;; Set up the input method.

(agda-input-setup)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Administrative details

(provide 'agda-input)
;;; agda-input.el ends here
#+END_SRC
** GAP
#+BEGIN_SRC emacs-lisp
(use-package gap-mode
  :ensure t
  :config
    (setq gap-executable "~/.local/bin/gap")
    (setq gap-start-options (list "-E")))

#+END_SRC
** DISABLED HAML
HAML support.

#+BEGIN_SRC emacs-lisp
  ;; (use-package haml-mode
  ;;   :ensure t)

  ;; (add-hook 'haml-mode-hook
  ;;           (lambda ()
  ;;             (setq indent-tabs-mode nil)
  ;;             (define-key haml-mode-map "\C-m" 'newline-and-indent)))
#+END_SRC
** DISABLED Completion
Taken from [[https://github.com/malb/emacs.d/blob/master/malb.org#latex][malb's emacs.d]].

#+BEGIN_SRC emacs-lisp
  ;; (use-package company
  ;;   :ensure t
  ;;   :config (progn
  ;; 	    (global-company-mode 1)))
#+END_SRC

I am no longer using company-auctex.

#+BEGIN_SRC emacs-lisp
  ;; (use-package company-auctex
  ;;   :ensure t
  ;;   :config (progn
  ;;             (defun company-auctex-labels (command &optional arg &rest ignored)
  ;; 	      "company-auctex-labels backend"
  ;; 	      (interactive (list 'interactive))
  ;; 	      (case command
  ;;                 (interactive (company-begin-backend 'company-auctex-labels))
  ;;                 (prefix (company-auctex-prefix "\\\\.*ref{\\([^}]*\\)\\="))
  ;;                 (candidates (company-auctex-label-candidates arg))))

  ;;             (add-to-list 'company-backends
  ;;                          '(company-auctex-macros
  ;;                            company-auctex-environments))

  ;;             (add-to-list 'company-backends #'company-auctex-labels)
  ;;             (add-to-list 'company-backends #'company-auctex-bibs)))
#+END_SRC
* Customization
** Theme
*** DISABLED Tomorrow night
#+BEGIN_SRC emacs-lisp
;(use-package base16-theme
;  :ensure t
;  :config
;  (load-theme 'base16-default-dark t))
#+END_SRC

*** Zenburn+Wombat
Uses the [[https://github.com/bbatsov/zenburn-emacs][Zenburn color theme]], which is a dark, low-contrast theme
ported from Vim. It also loads the [[https://github.com/jasonblewis/color-theme-wombat][Wombat theme]], also a dark theme
ported from Vim.

#+BEGIN_SRC emacs-lisp
; Zenburn theme
(use-package zenburn-theme
   :ensure t)
(load-theme 'zenburn t)

; Wombat theme
(load-theme 'wombat t)
#+END_SRC

*** DISABLED Spacemacs theme
#+BEGIN_SRC emacs-lisp
  ;; (use-package spacemacs-theme
  ;;   :ensure t
  ;;   :init
  ;;   (load-theme 'spacemacs-dark t)
  ;;   (setq spacemacs-theme-org-agenda-height nil)
  ;;   (setq spacemacs-theme-org-height nil)
  ;;   :config
  ;;   (set-face-attribute 'org-level-1 nil :height 1.0)
  ;;   (set-face-attribute 'org-level-2 nil :height 1.0)
  ;;   (set-face-attribute 'org-level-3 nil :height 1.0)
  ;;   (set-face-attribute 'org-scheduled-today nil :height 1.0)
  ;;   (set-face-attribute 'org-agenda-date-today nil :height 1.1)
  ;;   (set-face-attribute 'org-table nil :foreground "#008787")
  ;; )
#+END_SRC
*** DISABLED Nord
#+BEGIN_SRC emacs-lisp
;(use-package nord-theme :ensure t)
;(load-theme 'nord t)
#+END_SRC
*** DISABLED Dracula
#+BEGIN_SRC emacs-lisp
;;(use-package dracula-theme
;;  :ensure t)
#+END_SRC

** Dashboard
#+BEGIN_SRC emacs-lisp
(use-package dashboard
    :ensure t
    :diminish dashboard-mode
    :config
    (setq dashboard-banner-logo-title "Welcome to Emacs!")
    (setq dashboard-items '((recents  . 10)
                            (bookmarks . 10)))
    (dashboard-setup-startup-hook))
#+END_SRC

** Font
*** Iosevka
#+BEGIN_SRC emacs-lisp
; Iosevka
(add-to-list 'default-frame-alist '(font . "Iosevka42-11" ))
(set-face-attribute 'default t :font "Iosevka42-11" )
;(set-default-font "Iosevka")
#+END_SRC

*** DejaVu Sans
Fallback unicode font for Agda. It works great with Fira mono.

#+BEGIN_SRC emacs-lisp
(set-fontset-font "fontset-default" 'unicode "DejaVu Sans")
#+END_SRC

*** DISABLED Fira mono
Uses Fira as default font.

#+BEGIN_SRC emacs-lisp
; Fira mono
;(add-to-list 'default-frame-alist '(font . "Fira Mono-10" ))
;(set-face-attribute 'default t :font "Fira Mono-10" )
;(set-default-font "Fira Mono")
#+END_SRC

*** DISABLED Fira code
https://github.com/tonsky/FiraCode/wiki/Emacs-instructions

#+BEGIN_SRC emacs-lisp
  ;; This works when using emacs --daemon + emacsclient
  (add-hook 'after-make-frame-functions (lambda (frame) (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")))
  ;; This works when using emacs without server/client
  (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")
#+END_SRC
#+BEGIN_SRC emacs-lisp
   ; https://github.com/ekaschalk/.spacemacs.d/blob/master/layers/display/local/pretty-fonts/pretty-fonts.el
   ;;; API

   ;;;###autoload
   (defun pretty-fonts-set-fontsets (CODE-FONT-ALIST)
     "Utility to associate many unicode points with specified fonts."
     (--each CODE-FONT-ALIST
       (-let (((font . codes) it))
         (--each codes
           (set-fontset-font t `(,it . ,it) font)))))

   ;;;###autoload
   (defun pretty-fonts--add-kwds (FONT-LOCK-ALIST)
     "Exploits `font-lock-add-keywords' to apply regex-unicode replacements."
     (font-lock-add-keywords
      nil (--map (-let (((rgx uni-point) it))
                  `(,rgx (0 (progn
                              (compose-region
                               (match-beginning 1) (match-end 1)
                               ,(concat "\t" (list uni-point)))
                              nil))))
                FONT-LOCK-ALIST)))

   ;;;###autoload
   (defmacro pretty-fonts-set-kwds (FONT-LOCK-HOOKS-ALIST)
     "Set regex-unicode replacements to many modes."
     `(--each ,FONT-LOCK-HOOKS-ALIST
        (-let (((font-locks . mode-hooks) it))
          (--each mode-hooks
            (add-hook it (-partial 'pretty-fonts--add-kwds
                                   (symbol-value font-locks)))))))

   ;;; Fira Font

   (defconst pretty-fonts-fira-font
     '(;; OPERATORS
       ;; Pipes
       ("\\(<|\\)" #Xe14d) ("\\(<>\\)" #Xe15b) ("\\(<|>\\)" #Xe14e) ("\\(|>\\)" #Xe135)

       ;; Brackets
       ("\\(<\\*\\)" #Xe14b) ("\\(<\\*>\\)" #Xe14c) ("\\(\\*>\\)" #Xe104)
       ("\\(<\\$\\)" #Xe14f) ("\\(<\\$>\\)" #Xe150) ("\\(\\$>\\)" #Xe137)
       ("\\(<\\+\\)" #Xe155) ("\\(<\\+>\\)" #Xe156) ("\\(\\+>\\)" #Xe13a)

       ;; Equality
       ("\\(!=\\)" #Xe10e) ("\\(!==\\)"         #Xe10f) ("\\(=/=\\)" #Xe143)
       ("\\(/=\\)" #Xe12c) ("\\(/==\\)"         #Xe12d)
       ("\\(===\\)"#Xe13d) ("[^!/]\\(==\\)[^>]" #Xe13c)

       ;; Equality Special
       ("\\(||=\\)"  #Xe133) ("[^|]\\(|=\\)" #Xe134)
       ("\\(~=\\)"   #Xe166)
       ("\\(\\^=\\)" #Xe136)
       ("\\(=:=\\)"  #Xe13b)

       ;; Comparisons
       ("\\(<=\\)" #Xe141) ("\\(>=\\)" #Xe145)
       ("\\(</\\)" #Xe162) ("\\(</>\\)" #Xe163)

       ;; Shifts
       ("[^-=]\\(>>\\)" #Xe147) ("\\(>>>\\)" #Xe14a)
       ("[^-=]\\(<<\\)" #Xe15c) ("\\(<<<\\)" #Xe15f)

       ;; Dots
       ("\\(\\.-\\)"    #Xe122) ("\\(\\.=\\)" #Xe123)
       ("\\(\\.\\.<\\)" #Xe125)

       ;; Hashes
       ("\\(#{\\)"  #Xe119) ("\\(#(\\)"   #Xe11e) ("\\(#_\\)"   #Xe120)
       ("\\(#_(\\)" #Xe121) ("\\(#\\?\\)" #Xe11f) ("\\(#\\[\\)" #Xe11a)

       ;; REPEATED CHARACTERS
       ;; 2-Repeats
       ("\\(||\\)" #Xe132)
       ("\\(!!\\)" #Xe10d)
       ("\\(%%\\)" #Xe16a)
       ("\\(&&\\)" #Xe131)

       ;; 2+3-Repeats
       ("\\(##\\)"       #Xe11b) ("\\(###\\)"         #Xe11c) ("\\(####\\)" #Xe11d)
       ("\\(--\\)"       #Xe111) ("\\(---\\)"         #Xe112)
       ("\\({-\\)"       #Xe108) ("\\(-}\\)"          #Xe110)
       ("\\(\\\\\\\\\\)" #Xe106) ("\\(\\\\\\\\\\\\\\)" #Xe107)
       ("\\(\\.\\.\\)"   #Xe124) ("\\(\\.\\.\\.\\)"   #Xe126)
       ("\\(\\+\\+\\)"   #Xe138) ("\\(\\+\\+\\+\\)"   #Xe139)
       ("\\(//\\)"       #Xe12f) ("\\(///\\)"         #Xe130)
       ("\\(::\\)"       #Xe10a) ("\\(:::\\)"         #Xe10b)

       ;; ARROWS
       ;; Direct
       ("[^-]\\(->\\)" #Xe114) ("[^=]\\(=>\\)" #Xe13f)
       ("\\(<-\\)"     #Xe152)
       ("\\(-->\\)"    #Xe113) ("\\(->>\\)"    #Xe115)
       ("\\(==>\\)"    #Xe13e) ("\\(=>>\\)"    #Xe140)
       ("\\(<--\\)"    #Xe153) ("\\(<<-\\)"    #Xe15d)
       ("\\(<==\\)"    #Xe158) ("\\(<<=\\)"    #Xe15e)
       ("\\(<->\\)"    #Xe154) ("\\(<=>\\)"    #Xe159)

       ;; Branches
       ("\\(-<\\)"  #Xe116) ("\\(-<<\\)" #Xe117)
       ("\\(>-\\)"  #Xe144) ("\\(>>-\\)" #Xe148)
       ("\\(=<<\\)" #Xe142) ("\\(>>=\\)" #Xe149)
       ("\\(>=>\\)" #Xe146) ("\\(<=<\\)" #Xe15a)

       ;; Squiggly
       ("\\(<~\\)" #Xe160) ("\\(<~~\\)" #Xe161)
       ("\\(~>\\)" #Xe167) ("\\(~~>\\)" #Xe169)
       ("\\(-~\\)" #Xe118) ("\\(~-\\)"  #Xe165)

       ;; MISC
       ("\\(www\\)"                   #Xe100)
       ("\\(<!--\\)"                  #Xe151)
       ("\\(~@\\)"                    #Xe164)
       ("[^<]\\(~~\\)"                #Xe168)
       ("\\(\\?=\\)"                  #Xe127)
       ("[^=]\\(:=\\)"                #Xe10c)
       ("\\(/>\\)"                    #Xe12e)
       ("[^\\+<>]\\(\\+\\)[^\\+<>]"   #Xe16d)
       ("[^:=]\\(:\\)[^:=]"           #Xe16c)
       ("\\(<=\\)"                    #Xe157))
     "Fira font ligatures and their regexes")

   (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol")
#+END_SRC
#+BEGIN_SRC emacs-lisp
;(pretty-fonts-set-kwds
;  '((pretty-fonts-fira-font prog-mode-hook org-mode-hook)))
#+END_SRC
*** DISABLED Iosevka ligatures
Iosevka-haskell must be installed.

#+BEGIN_SRC emacs-lisp
  ;; ;; https://gist.github.com/mrkgnao/49c7480e1df42405a36b7ab09fe87f3d

  ;; ;; I use Spacemacs, so I put this in user-config
  ;; ;; Note that the script above only generates the long list of pairs.
  ;; ;; The surrounding code is stolen from the PragmataPro scripts floating around on Gist.

  ;;   (setq prettify-symbols-unprettify-at-point 'right-edge)

  ;;   (defun setup-iosevka-ligatures ()
  ;;     (setq prettify-symbols-alist
  ;;           (append prettify-symbols-alist '(

  ;; ;; Double-ended hyphen arrows ----------------
  ;; ("<->" . #Xe100)
  ;; ("<-->" . #Xe101)
  ;; ("<--->" . #Xe102)
  ;; ("<---->" . #Xe103)
  ;; ("<----->" . #Xe104)

  ;; ;; Double-ended equals arrows ----------------
  ;; ("<=>" . #Xe105)
  ;; ("<==>" . #Xe106)
  ;; ("<===>" . #Xe107)
  ;; ("<====>" . #Xe108)
  ;; ("<=====>" . #Xe109)

  ;; ;; Double-ended asterisk operators ----------------
  ;; ("<**>" . #Xe10a)
  ;; ("<***>" . #Xe10b)
  ;; ("<****>" . #Xe10c)
  ;; ("<*****>" . #Xe10d)

  ;; ;; HTML comments ----------------
  ;; ("<!--" . #Xe10e)
  ;; ("<!---" . #Xe10f)

  ;; ;; Three-char ops with discards ----------------
  ;; ("<$" . #Xe110)
  ;; ("<$>" . #Xe111)
  ;; ("$>" . #Xe112)
  ;; ("<." . #Xe113)
  ;; ("<.>" . #Xe114)
  ;; (".>" . #Xe115)
  ;; ("<*" . #Xe116)
  ;; ("<*>" . #Xe117)
  ;; ("*>" . #Xe118)
  ;; ("<\\" . #Xe119)
  ;; ("<\\>" . #Xe11a)
  ;; ("\\>" . #Xe11b)
  ;; ("</" . #Xe11c)
  ;; ("</>" . #Xe11d)
  ;; ("/>" . #Xe11e)
  ;; ("<\"" . #Xe11f)
  ;; ("<\">" . #Xe120)
  ;; ("\">" . #Xe121)
  ;; ("<'" . #Xe122)
  ;; ("<'>" . #Xe123)
  ;; ("'>" . #Xe124)
  ;; ("<^" . #Xe125)
  ;; ("<^>" . #Xe126)
  ;; ("^>" . #Xe127)
  ;; ("<&" . #Xe128)
  ;; ("<&>" . #Xe129)
  ;; ("&>" . #Xe12a)
  ;; ("<%" . #Xe12b)
  ;; ("<%>" . #Xe12c)
  ;; ("%>" . #Xe12d)
  ;; ("<@" . #Xe12e)
  ;; ("<@>" . #Xe12f)
  ;; ("@>" . #Xe130)
  ;; ("<#" . #Xe131)
  ;; ("<#>" . #Xe132)
  ;; ("#>" . #Xe133)
  ;; ("<+" . #Xe134)
  ;; ("<+>" . #Xe135)
  ;; ("+>" . #Xe136)
  ;; ("<-" . #Xe137)
  ;; ("<->" . #Xe138)
  ;; ("->" . #Xe139)
  ;; ("<!" . #Xe13a)
  ;; ("<!>" . #Xe13b)
  ;; ("!>" . #Xe13c)
  ;; ("<?" . #Xe13d)
  ;; ("<?>" . #Xe13e)
  ;; ("?>" . #Xe13f)
  ;; ("<|" . #Xe140)
  ;; ("<|>" . #Xe141)
  ;; ("|>" . #Xe142)
  ;; ("<:" . #Xe143)
  ;; ("<:>" . #Xe144)
  ;; (":>" . #Xe145)

  ;; ;; Colons ----------------
  ;; ("::" . #Xe146)
  ;; (":::" . #Xe147)
  ;; ("::::" . #Xe148)

  ;; ;; Arrow-like operators ----------------
  ;; ("->" . #Xe149)
  ;; ("->-" . #Xe14a)
  ;; ("->--" . #Xe14b)
  ;; ("->>" . #Xe14c)
  ;; ("->>-" . #Xe14d)
  ;; ("->>--" . #Xe14e)
  ;; ("->>>" . #Xe14f)
  ;; ("->>>-" . #Xe150)
  ;; ("->>>--" . #Xe151)
  ;; ("-->" . #Xe152)
  ;; ("-->-" . #Xe153)
  ;; ("-->--" . #Xe154)
  ;; ("-->>" . #Xe155)
  ;; ("-->>-" . #Xe156)
  ;; ("-->>--" . #Xe157)
  ;; ("-->>>" . #Xe158)
  ;; ("-->>>-" . #Xe159)
  ;; ("-->>>--" . #Xe15a)
  ;; (">-" . #Xe15b)
  ;; (">--" . #Xe15c)
  ;; (">>-" . #Xe15d)
  ;; (">>--" . #Xe15e)
  ;; (">>>-" . #Xe15f)
  ;; (">>>--" . #Xe160)
  ;; ("=>" . #Xe161)
  ;; ("=>=" . #Xe162)
  ;; ("=>==" . #Xe163)
  ;; ("=>>" . #Xe164)
  ;; ("=>>=" . #Xe165)
  ;; ("=>>==" . #Xe166)
  ;; ("=>>>" . #Xe167)
  ;; ("=>>>=" . #Xe168)
  ;; ("=>>>==" . #Xe169)
  ;; ("==>" . #Xe16a)
  ;; ("==>=" . #Xe16b)
  ;; ("==>==" . #Xe16c)
  ;; ("==>>" . #Xe16d)
  ;; ("==>>=" . #Xe16e)
  ;; ("==>>==" . #Xe16f)
  ;; ("==>>>" . #Xe170)
  ;; ("==>>>=" . #Xe171)
  ;; ("==>>>==" . #Xe172)
  ;; (">=" . #Xe173)
  ;; (">==" . #Xe174)
  ;; (">>=" . #Xe175)
  ;; (">>==" . #Xe176)
  ;; (">>>=" . #Xe177)
  ;; (">>>==" . #Xe178)
  ;; ("<-" . #Xe179)
  ;; ("-<-" . #Xe17a)
  ;; ("--<-" . #Xe17b)
  ;; ("<<-" . #Xe17c)
  ;; ("-<<-" . #Xe17d)
  ;; ("--<<-" . #Xe17e)
  ;; ("<<<-" . #Xe17f)
  ;; ("-<<<-" . #Xe180)
  ;; ("--<<<-" . #Xe181)
  ;; ("<--" . #Xe182)
  ;; ("-<--" . #Xe183)
  ;; ("--<--" . #Xe184)
  ;; ("<<--" . #Xe185)
  ;; ("-<<--" . #Xe186)
  ;; ("--<<--" . #Xe187)
  ;; ("<<<--" . #Xe188)
  ;; ("-<<<--" . #Xe189)
  ;; ("--<<<--" . #Xe18a)
  ;; ("-<" . #Xe18b)
  ;; ("--<" . #Xe18c)
  ;; ("-<<" . #Xe18d)
  ;; ("--<<" . #Xe18e)
  ;; ("-<<<" . #Xe18f)
  ;; ("--<<<" . #Xe190)
  ;; ("<=" . #Xe191)
  ;; ("=<=" . #Xe192)
  ;; ("==<=" . #Xe193)
  ;; ("<<=" . #Xe194)
  ;; ("=<<=" . #Xe195)
  ;; ("==<<=" . #Xe196)
  ;; ("<<<=" . #Xe197)
  ;; ("=<<<=" . #Xe198)
  ;; ("==<<<=" . #Xe199)
  ;; ("<==" . #Xe19a)
  ;; ("=<==" . #Xe19b)
  ;; ("==<==" . #Xe19c)
  ;; ("<<==" . #Xe19d)
  ;; ("=<<==" . #Xe19e)
  ;; ("==<<==" . #Xe19f)
  ;; ("<<<==" . #Xe1a0)
  ;; ("=<<<==" . #Xe1a1)
  ;; ("==<<<==" . #Xe1a2)
  ;; ("=<" . #Xe1a3)
  ;; ("==<" . #Xe1a4)
  ;; ("=<<" . #Xe1a5)
  ;; ("==<<" . #Xe1a6)
  ;; ("=<<<" . #Xe1a7)
  ;; ("==<<<" . #Xe1a8)

  ;; ;; Monadic operators ----------------
  ;; (">=>" . #Xe1a9)
  ;; (">->" . #Xe1aa)
  ;; (">-->" . #Xe1ab)
  ;; (">==>" . #Xe1ac)
  ;; ("<=<" . #Xe1ad)
  ;; ("<-<" . #Xe1ae)
  ;; ("<--<" . #Xe1af)
  ;; ("<==<" . #Xe1b0)

  ;; ;; Composition operators ----------------
  ;; (">>" . #Xe1b1)
  ;; (">>>" . #Xe1b2)
  ;; ("<<" . #Xe1b3)
  ;; ("<<<" . #Xe1b4)

  ;; ;; Lens operators ----------------
  ;; (":+" . #Xe1b5)
  ;; (":-" . #Xe1b6)
  ;; (":=" . #Xe1b7)
  ;; ("+:" . #Xe1b8)
  ;; ("-:" . #Xe1b9)
  ;; ("=:" . #Xe1ba)
  ;; ("=^" . #Xe1bb)
  ;; ("=+" . #Xe1bc)
  ;; ("=-" . #Xe1bd)
  ;; ("=*" . #Xe1be)
  ;; ("=/" . #Xe1bf)
  ;; ("=%" . #Xe1c0)
  ;; ("^=" . #Xe1c1)
  ;; ("+=" . #Xe1c2)
  ;; ("-=" . #Xe1c3)
  ;; ("*=" . #Xe1c4)
  ;; ("/=" . #Xe1c5)
  ;; ("%=" . #Xe1c6)

  ;; ;; Logical ----------------
  ;; ("/\\" . #Xe1c7)
  ;; ("\\/" . #Xe1c8)

  ;; ;; Semigroup/monoid operators ----------------
  ;; ("<>" . #Xe1c9)
  ;; ("<+" . #Xe1ca)
  ;; ("<+>" . #Xe1cb)
  ;; ("+>" . #Xe1cc)
  ;; ))))

  ;;   (defun refresh-pretty ()
  ;;     (prettify-symbols-mode -1)
  ;;     (prettify-symbols-mode +1))

  ;;   ;; Hooks for modes in which to install the Iosevka ligatures
  ;;   (mapc (lambda (hook)
  ;;           (add-hook hook (lambda () (setup-iosevka-ligatures) (refresh-pretty))))
  ;;         '(text-mode-hook
  ;;           prog-mode-hook
  ;;           haskell-mode-hook))
  ;; (global-prettify-symbols-mode +1)
#+END_SRC

** Toolbar and menubar
Disable the toolbar and menubar

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tooltip-mode -1)
#+END_SRC

** Cursor
Cursor should not blink

#+BEGIN_SRC emacs-lisp
(setq blink-cursor-mode nil)
#+END_SRC

** Yes-no to y-n
Yes-no questions are unnecessarily long.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Word wrapping and selection mode
#+BEGIN_SRC emacs-lisp
(setq-default word-wrap 1)
(delete-selection-mode 1)
#+END_SRC

** All the icons
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t)
#+END_SRC

** Custom file
Loads the customize file, follows this [[http://emacsblog.org/2008/12/06/quick-tip-detaching-the-custom-file/][article]]:

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file 'noerror)
#+END_SRC

** What face?
Indicates what face are we using currently under the cursor.

#+BEGIN_SRC emacs-lisp
  (defun what-face (pos)
    (interactive "d")
    (let ((face (or (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face))))
      (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+END_SRC

** Which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config (which-key-mode))
#+END_SRC

** Electric pair mode
#+BEGIN_SRC emacs-lisp
(electric-pair-mode 1)
#+END_SRC

** Spaceline
#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :ensure t
  :demand t
  :init
    (setq powerline-default-separator 'contour)
  :config
    (require 'spaceline-config)
    (spaceline-emacs-theme)
    (setq-default spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
    (spaceline-toggle-minor-modes-off)
)
#+END_SRC

** DISABLED Golden ratio
#+BEGIN_SRC emacs-lisp
  ;; (use-package golden-ratio
  ;;   :ensure t
  ;;   :init
  ;;     (golden-ratio-mode 1)
  ;;   :config
  ;;     (add-to-list 'golden-ratio-exclude-modes "agda2-mode")
  ;;     (add-to-list 'golden-ratio-exclude-modes "compilation-mode")
  ;;     (add-to-list 'golden-ratio-exclude-modes "coq-mode")
  ;;     (add-to-list 'golden-ratio-exclude-modes "coq-goals-mode")
  ;;     (add-to-list 'golden-ratio-exclude-modes "coq-response-mode")
  ;; )
#+END_SRC
** Volatile highlights
([[http://pragmaticemacs.com/emacs/volatile-highlights/][From Pragmatic Emacs]]) The package volatile highlights temporarily
highlights changes to the buffer associated with certain commands that
add blocks of text at once. An example is that if you paste (yank) a
block of text, it will be highlighted until you press the next
key. This is just a small tweak, but gives a nice bit of visual
feedback.

#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :ensure t
  :config
    (volatile-highlights-mode t)
)
#+END_SRC

** Rainbow delimiters
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'org-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'LaTeX-mode-hook #'rainbow-delimiters-mode)
)
#+END_SRC

** Centered window
#+BEGIN_SRC emacs-lisp
(use-package centered-window :ensure t)
#+END_SRC
* Translation
** Google translate
#+BEGIN_SRC emacs-lisp
(use-package google-translate
  :ensure t)

(require 'google-translate)
(require 'google-translate-default-ui)
(global-set-key "\C-ct" 'google-translate-at-point)
(global-set-key "\C-cT" 'google-translate-query-translate)

(setq google-translate-default-source-language "en")
(setq google-translate-default-target-language "es")
#+END_SRC
** Engine-mode
[[https://github.com/hrs/engine-mode][Engine mode]] allows us to use a search engine directly on Emacs. It binds the different 
search engines to =C-x / ?=, where =?= is a char representing the engine.

#+BEGIN_SRC emacs-lisp
(use-package engine-mode
  :ensure t)

(defengine duckduckgo
  "https://duckduckgo.com/?q=%s"
  :keybinding "d")
(defengine github
  "https://github.com/search?ref=simplesearch&q=%s"
  :keybinding "g")
(defengine google
  "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")
(defengine rfcs
  "http://pretty-rfc.herokuapp.com/search?q=%s")
(defengine stack-overflow
  "https://stackoverflow.com/search?q=%s"
  :keybinding "s")
(defengine wikipedia
  "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
  :keybinding "w")
(defengine wiktionary
  "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

(engine-mode t)
#+END_SRC
** Pronounce word
Pronounces an English word using the howjsay dictionary.

#+BEGIN_SRC emacs-lisp
(defun mroman42/pronounce (word)
  (interactive)
  (start-process-shell-command "howjsay" nil 
    (concat "mplayer " "https://www.howjsay.com/mp3/" word ".mp3"))
)
#+END_SRC

** DISABLED dict-replace
My dict-replace package. I am no longer using it.

#+BEGIN_SRC emacs-lisp
  ;(load-file "~/.emacs.d/dict-replace.el")
  ;(global-set-key (kbd "<f5>") 'dict-translate)
#+END_SRC
* Evil
Use Emacs keybindings by default. Change to Vi keybindings using =C-z=.
Spaceline is colored in blue or orange depending on the current mode.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :init 
      (evil-mode 1)
      (global-undo-tree-mode 0)
      (evil-emacs-state)
    :config
      (setq evil-default-state 'emacs)
    )
#+END_SRC

* Org-mode
** Modules, plus-contrib
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure org-plus-contrib
  :config (define-key org-mode-map (kbd "C-<tab>") nil))

(require 'org-drill)
(require 'org-habit)
(require 'org-checklist)

;; List of modules
(add-to-list 'org-modules "org-drill")
(add-to-list 'org-modules "org-bbdb")
(add-to-list 'org-modules "org-bibtex")
(add-to-list 'org-modules "org-docview")
(add-to-list 'org-modules "org-gnus")
(add-to-list 'org-modules "org-habit")
(add-to-list 'org-modules "org-info")
(add-to-list 'org-modules "org-irc")
(add-to-list 'org-modules "org-mhe")
(add-to-list 'org-modules "org-protocol")
(add-to-list 'org-modules "org-rmail")
(add-to-list 'org-modules "org-w3m")
(add-to-list 'org-modules "org-checklist")
#+END_SRC

** org-ref
#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :ensure t)

(setq org-ref-default-bibliography '("~/projects/math/math.bib"))
#+END_SRC

** org-agenda
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
	'(("c" "Complete agenda, todo and waiting tasks"
           ((agenda)
            (tags-todo "-habit-notask+TODO=\"TODO\"-SCHEDULED>\"<today>\"")
            (tags-todo "-habit-notask+TODO=\"WAIT\"-SCHEDULED>\"<today>\"")
            ))))
  (setq org-agenda-tag-filter-preset '("-notask"))
  (setq org-agenda-files '("~/Dropbox/orgzly/Tasks.org"))
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-todo-ignore-scheduled 'past)
  (setq org-agenda-show-future-repeats nil)
  (setq org-agenda-start-day "-1d")
  (setq org-agenda-span 7)
  (setq org-agenda-start-on-weekday nil)
#+END_SRC

*** To-do dependencies
https://orgmode.org/manual/TODO-dependencies.html#TODO-dependencies

#+BEGIN_SRC emacs-lisp
(setq org-enforce-todo-dependencies t)
(setq org-agenda-dim-blocked-tasks 'invisible)
#+END_SRC
*** Habits
#+BEGIN_SRC emacs-lisp
(setq org-habit-show-habits-only-for-today t)
#+END_SRC
** org-refile
From [[https://www.reddit.com/r/emacs/comments/4366f9/how_do_orgrefiletargets_work/czg008y/][this reddit comment]].

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '(
   (nil :maxlevel . 2) 
   (org-agenda-files :maxlevel . 2) 
   ("~/Dropbox/orgzly/Someday.org" :maxlevel . 2)
   ("~/Dropbox/orgzly/Tasks.org" :maxlevel . 2)
   ("~/Dropbox/orgzly/Reference.org" :maxlevel . 2)
   ("~/Dropbox/orgzly/Notes.org" :maxlevel . 2)
   ("~/Dropbox/orgzly/Inbox.org" :maxlevel . 1)
   ("~/Dropbox/orgzly/Archive.org" :maxlevel . 1)
))
(setq org-outline-path-complete-in-steps nil)         ; Refile in a single go
(setq org-refile-use-outline-path t)                  ; Show full paths for refiling
#+END_SRC

From [[https://blog.aaronbieber.com/2017/03/19/organizing-notes-with-refile.html][this post]], how to refile to the top level.

#+BEGIN_SRC emacs-lisp
(setq org-refile-use-outline-path 'file)
(setq org-outline-path-complete-in-steps nil)
#+END_SRC

Save after refiling or archiving ([[https://emacs.stackexchange.com/questions/26923/org-mode-getting-errors-when-auto-saving-after-refiling][from SO]]).

#+BEGIN_SRC emacs-lisp
(advice-add 'org-refile :after
        (lambda (&rest _)
        (org-save-all-org-buffers)))
(advice-add 'org-archive-subtree :after
        (lambda (&rest _)
        (org-save-all-org-buffers)))
#+END_SRC

*** archive
Stores org files in =~/org=. Defines location of index, agenda and todo files.

#+BEGIN_SRC emacs-lisp
  (setq org-directory m42/org-folder)
  (setq org-archive-location (concat m42/archive-file "::* From %s"))
#+END_SRC
** Keybindings
*** Agenda and capture
Basic keybindings for org-mode.

#+BEGIN_SRC emacs-lisp
  (setq org-export-coding-system 'utf-8)
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key (kbd "C-c c") 'org-capture)
  (global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

*** Navigation
Navigation between headings.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 
            (lambda ()
              (local-set-key "\M-n" 'outline-next-visible-heading)
              (local-set-key "\M-p" 'outline-previous-visible-heading)
              ))
#+END_SRC

*** Elisp link confirmation
#+BEGIN_SRC emacs-lisp
(setq org-confirm-elisp-link-function nil)
#+END_SRC

** Customization
Sets attributes for the standard org-mode faces.

*** Pretty entities
#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities nil)
#+END_SRC

*** Bullets
#+BEGIN_SRC emacs-lisp
  ;; Org-bullets
  (use-package org-bullets
    :ensure t)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))

;  (setq org-bullets-bullet-list '("◉" "○" "◉" "○"))
  (setq org-bullets-bullet-list '("*"))
#+END_SRC

*** Indentation
#+BEGIN_SRC emacs-lisp
  ;; Indentation
  (setq org-startup-indented t)
#+END_SRC

*** Faces
#+BEGIN_SRC emacs-lisp
  ;; Faces
  (set-face-attribute 'org-level-1 nil
     :inherit 'outline-1
     :weight 'normal
;     :foreground "#d08770" ; Nord Aurora 12
;    :foreground "#5e81ac" ; Nord Frost 10
     :height 1.0)

  (set-face-attribute 'org-level-2 nil
    :inherit 'outline-1
    :weight 'normal
;    :foreground "#ebcb8b" ; Nord Aurora 13
;    :foreground "#81a1c1" ; Nord Frost 9
    :height 1.0)

  (set-face-attribute 'org-level-3 nil 
    :inherit 'outline-3 
;    :foreground "#a3be8c" ; Nord Aurora 14
;    :foreground "#88c0d0" ; Nord Frost 8
    :weight 'normal)

  (set-face-attribute 'org-level-4 nil
    :inherit 'outline-3 
    :foreground "light steel blue"
;    :foreground "#5e81ac" ; Nord Frost 10
;    :foreground "#8fbcbb" ; Nord Frost 7
    :weight 'normal)

  (set-face-attribute 'org-level-5 nil
    :inherit 'outline-4 
;    :foreground "light sky blue" 
    :foreground "#81a1c1" ; Nord Frost 9
    :weight 'normal)

  (set-face-attribute 'org-level-6 nil
    :inherit 'outline-4
    ;:foreground "powder blue"
    :foreground "#88c0d0" ; Nord Frost 8
    )

  (set-face-attribute 'org-level-7 nil
    :inherit 'outline-7
    :foreground "#8fbcbb" ; Nord Frost 7
    ;:foreground "pale green"
    )

  (set-face-attribute 'org-level-8 nil
    :inherit 'outline-7
    ;:foreground "light green"
    :foreground "#b48ead" ; Nord Aurora 15
    )

  (set-face-attribute 'org-link nil
    :inherit 'link
;    :foreground "SlateGray1"
;    :foreground "#e5e9f0" ; Nord Snow Storm 5
    :weight 'normal
    :underline nil)
#+END_SRC

*** Ultra-bold emphasis
#+BEGIN_SRC emacs-lisp
(setq org-emphasis-alist 
  '(("*" (:weight ultra-bold)) 
    ("/" italic) 
    ("_" underline) 
    ("=" org-verbatim verbatim) 
    ("~" org-code verbatim) 
    ("+" (:strike-through t))))
#+END_SRC
*** Emphasis markers
#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC
*** Tags
#+BEGIN_SRC emacs-lisp
(setq org-tags-column -100)
#+END_SRC
*** Final blank line
https://blog.aaronbieber.com/2016/01/30/dig-into-org-mode.html

"I tend to leave a blank line at the end of the content of each task
entry. This causes Org to automatically place a blank line before a
new heading or plain text list item, just the way I like it."

#+BEGIN_SRC emacs-lisp
(setq org-blank-before-new-entry (quote ((heading . t) (plain-list-item . auto))))
#+END_SRC

*** Log-done
https://blog.aaronbieber.com/2016/01/30/dig-into-org-mode.html

"I like to know when tasks have changed status. Setting this option
causes Org to insert an annotation in a task when it is marked as done
including a timestamp of when exactly that happened."

#+BEGIN_SRC emacs-lisp
(setq org-log-done (quote time))
#+END_SRC

"Adding yet further auditing, this option causes Org to insert
annotations when you change the deadline of a task, which will note
the previous deadline date and when it was changed. Very useful for
figuring out how many times you “kicked the can down the road.”"

#+BEGIN_SRC emacs-lisp
(setq org-log-redeadline (quote time))
(setq org-log-reschedule (quote time))
#+END_SRC

** Export
*** Report without parts
#+BEGIN_SRC emacs-lisp
(add-to-list 'org-latex-classes
           '("report-noparts"
              "\\documentclass{report}"
              ("\\chapter{%s}" . "\\chapter*{%s}")
              ("\\section{%s}" . "\\section*{%s}")
              ("\\subsection{%s}" . "\\subsection*{%s}")
              ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
              ("\\paragraph{%s}" . "\\paragraph*{%s}")
              ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC

*** Beamer
Exports to beamer. Defines the beamer class.

#+BEGIN_SRC emacs-lisp
  (require 'ox-latex)
  (add-to-list 'org-latex-classes
               '("beamer"
                 "\\documentclass\[presentation\]\{beamer\}"
                 ("\\section\{%s\}" . "\\section*\{%s\}")
                 ("\\subsection\{%s\}" . "\\subsection*\{%s\}")
                 ("\\subsubsection\{%s\}" . "\\subsubsection*\{%s\}")))
  (require 'ox-beamer)
#+END_SRC

*** Reveal.js
The configuration allowing me to do *Reveal.js* presentations using org-mode.
This was taken from [[http://cestlaz.github.io/posts/using-emacs-11-reveal][C'est la Z]].

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :ensure ox-reveal)

  (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
  (setq org-reveal-mathjax t)

  (use-package htmlize
    :ensure t)
#+END_SRC

*** Bootstrap
#+BEGIN_SRC emacs-lisp
  (use-package ox-twbs
    :ensure ox-twbs)
#+END_SRC
*** Export all
#+BEGIN_SRC emacs-lisp
  (defun m42/org-export-all-html ()
    "Export all subtrees that are *not* tagged with :noexport: to
    separate files. Note that subtrees must have the
    :EXPORT_FILE_NAME: property set to a unique value for this to
    work properly."
   (interactive)
   (org-map-entries 
      (lambda () 
         (if (org-entry-get (point) "EXPORT_FILE_NAME") 
           (funcall 'org-html-export-to-html nil t))) "-noexport" nil))
#+END_SRC

** Babel
Loads =org-babel= languages.

#+BEGIN_SRC emacs-lisp
(use-package ob-sagemath
  :ensure t)
(use-package ob-ipython
  :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (require 'ob-C)
  (require 'ob-python)
  (org-babel-do-load-languages
   'org-babel-load-languages
    '( (ruby . t)
       (python . t)
       (haskell . t)
       (C . t)
       (emacs-lisp . t)
       (ditaa . t)
       (sagemath . t)
       (translate . t)
       (latex . t)
       (shell . t)
       (ipython . t)
     ))
#+END_SRC

*** org-edit-special
https://emacs.stackexchange.com/a/8168/12208

#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window)
;  (defadvice org-edit-src-code (around set-buffer-file-name activate compile)
;    (let ((file-name (buffer-file-name))) ;; (1)
;      ad-do-it                            ;; (2)
;      (setq buffer-file-name file-name))) ;; (3)
#+END_SRC

*** Sage
Org-babel-sage configuration:

#+BEGIN_SRC emacs-lisp
  ;; Ob-sagemath supports only evaluating with a session.
  (setq org-babel-default-header-args:sage '((:session . t)
                                             (:results . "output")))

  ;; C-c c for asynchronous evaluating (only for SageMath code blocks).
  ;  (with-eval-after-load "org"
  ;     (define-key org-mode-map (kbd "C-c c") 'ob-sagemath-execute-async))

  ;; Do not confirm before evaluation
  (setq org-confirm-babel-evaluate nil)

  ;; Do not evaluate code blocks when exporting.
  ; (setq org-export-babel-evaluate nil)

  ;; Show images when opening a file.
  (setq org-startup-with-inline-images t)

  ;; Show images after evaluating code blocks.
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+END_SRC

*** Haskell
Uses =runhaskell= when it outputs the results. Taken from
a great [[http://quickhack.net/nom/blog/2012-08-31-org-babel-and-haskell.html][article]] (in Japanese!) by Yoshinari Nomura.

#+BEGIN_SRC emacs-lisp
      (defadvice org-babel-haskell-initiate-session
        (around org-babel-haskell-initiate-session-advice)
        (let* ((buff (get-buffer "*haskell*"))
               (proc (if buff (get-buffer-process buff)))
               (type (cdr (assoc :result-type 'params)))
               (haskell-program-name
                (if (equal type 'output) "runhaskell-ob" "ghci")))
          (if proc (kill-process proc))
          (sit-for 0)
          (if buff (kill-buffer buff))
          ad-do-it))

      (ad-activate 'org-babel-haskell-initiate-session)
#+END_SRC

*** Ditaa
Path to Ditaa
#+BEGIN_SRC emacs-lisp
  (setq org-ditaa-jar-path "/usr/share/java/ditaa/ditaa-0_9.jar")
#+END_SRC
** Wiki
Using the org-wiki package.
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/org-wiki")
(require 'org-wiki)
(setq org-wiki-location "~/org/wiki")
#+END_SRC

** Calfw
#+BEGIN_SRC emacs-lisp
  (use-package calfw
    :ensure t
    :config
      (setq cfw:org-overwrite-default-keybinding t)
    )

  (use-package calfw-org
    :ensure t
    )

  (setq cfw:display-calendar-holidays nil)
#+END_SRC

** Latex in org
Uses =C-ñ= to preview formulas:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-ñ") 'org-toggle-latex-fragment)

  ;; Zoom
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 1.2))
#+END_SRC

*** Default packages
#+BEGIN_SRC emacs-lisp
  ;; (setq org-latex-default-packages-alist
  ;;   (quote
  ;;     (("utf8x" "inputenc" t)
  ;;      ("T1" "fontenc" t)
  ;;      ("" "fixltx2e" nil)
  ;;      ("" "graphicx" t)
  ;;      ("" "grffile" t)
  ;;      ("" "longtable" nil)
  ;;      ("" "wrapfig" nil)
  ;;      ("" "rotating" nil)
  ;;      ("normalem" "ulem" t)
  ;;      ("" "amsmath" t)
  ;;      ("" "textcomp" t)
  ;;      ("" "amssymb" t)
  ;;      ("" "capt-of" nil)
  ;;      ("colorlinks=true" "hyperref" nil))))
#+END_SRC

*** Ignore headlines
#+BEGIN_SRC emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+END_SRC

*** scrbook
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("scrbook" "\\documentclass{scrbook}"
                 ("\\part{%s}" . "\\part*{%s}")
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}"))))
#+END_SRC

*** scrrept
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("scrreprt" "\\documentclass{scrreprt}"
                 ("\\part{%s}" . "\\part*{%s}")
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}"))))
#+END_SRC

*** minted
#+BEGIN_SRC emacs-lisp
(setq org-latex-listings 'minted
      org-latex-packages-alist '(("" "minted")))
(setq org-latex-minted-options
     '(("frame" "lines") 
       ))
#+END_SRC
*** cd-latex
#+BEGIN_SRC emacs-lisp
  (use-package cdlatex
    :ensure t)

  (add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+END_SRC

*** Latex math mode
Requires Latex to use =latex-math-mode=. It is activated by default.

#+BEGIN_SRC emacs-lisp
  (use-package tex
    :ensure auctex)
  (require 'latex)

  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
  (add-hook 'org-mode-hook 'LaTeX-math-mode)
#+END_SRC

Abbreviations on =latex-math-mode=.

#+BEGIN_SRC emacs-lisp
  (setq LaTeX-math-abbrev-prefix "ç")
  (setq LaTeX-math-list
    (quote
      ((";" "mathbb{" "" nil)
       ("=" "cong" "" nil)
       ("<right>" "longrightarrow" "" nil)
       ("<left>" "longleftarrow" "" nil)
       ("C-<right>" "Longrightarrow" "" nil)
       ("C-<left>" "Longleftarrow" "" nil)
       ("^" "widehat" "" nil)
       ("~" "widetilde" "" nil)
       ("'" "\partial" "" nil)
       ("0" "varnothing" "" nil)
       ("C-(" "left(" "" nil)
       ("C-)" "right)" "" nil)
       )))
#+END_SRC

*** Conmutative diagrams
Conmutative diagrams with the =tikz-cd= package.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "tikz" t))
  (eval-after-load "preview"
    '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{tikzpicture}" t))
  (setq org-latex-create-formula-image-program 'imagemagick)
#+END_SRC

*** Zooming & scale
Zooms latex image previews along with the text using =C-x C-+=.

#+BEGIN_SRC emacs-lisp
;  (defun update-org-latex-fragment-scale ()
;    (let ((text-scale-factor (expt text-scale-mode-step text-scale-mode-amount)))
;      (plist-put org-format-latex-options :scale (* 1.2 text-scale-factor)))
;  )
;  (add-hook 'text-scale-mode-hook 'update-org-latex-fragment-scale)
#+END_SRC
** Pinta in org
Creates an image using =imagemagick= and opens
a =pinta= window to edit it.

# It should be generalized to an editor-agnostic function,
# not using pinta, but the given editor.

#+BEGIN_SRC emacs-lisp
  (setq pinta-dir "./images/")
  (setq pinta-dimension "300x300")

  (defun org-pinta (filename)
    "Creates an image using pinta"
    (interactive "sImage name: ")

    (let ((file (concat pinta-dir "/" filename ".png")))
      ; creates the image, opens pinta
      (shell-command (concat "mkdir -p $(dirname " file ") && touch " file))
      (shell-command (concat "convert -size " pinta-dimension " xc:white png24:" file))
      (shell-command (concat "pinta " file))

      ; inserts the image in the current buffer
      (insert "#+begin_center")
      (newline)
      (insert "#+attr_latex: :width 50px")
      (newline)
      (insert (concat "[[" file "]]"))
      (newline)
      (insert "#+end_center")
    )
  )
#+END_SRC

#+begin_center
#+attr_latex: :width 50px
[[./pinta//painting.png]]
#+end_center
** Pomodoro
#+BEGIN_SRC emacs-lisp
(use-package org-pomodoro
  :ensure t)
#+END_SRC
** Checkboxes
#+BEGIN_SRC emacs-lisp
(setq org-checkbox-hierarchical-statistics t)
#+END_SRC
** Clock
Inspired by http://fdavidcl.me/blog/2017/11/30/time-tracking-org/

#+BEGIN_SRC emacs-lisp
(add-hook 'org-clock-in-hook 'save-buffer)
(add-hook 'org-clock-out-hook 'save-buffer)
(setq org-clock-mode-line-total 'current)
#+END_SRC

** org-id
:PROPERTIES:
:ID:       b3cc359a-f2da-4fa9-917f-9d9bc59ffd1f
:END:

#+BEGIN_SRC emacs-lisp
(require 'org-id)
(setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
;; (org-id-update-id-locations)
#+END_SRC

** Drill
#+BEGIN_SRC emacs-lisp
(defun m42/org-drill-cram-tree ()
  (interactive)
  (org-drill-cram 'tree))
(setq org-drill-learn-fraction 0.35)
(setq org-drill-add-random-noise-to-intervals-p t)
(setq org-drill-maximum-duration 25)
(setq org-drill-save-buffers-after-drill-sessions-p nil)
(setq org-drill-hide-item-headings-p t)
;(setq org-drill-spaced-repetition-algorithm 'sm2)
;(setq org-drill-scope 'tree)
#+END_SRC

*** org-drill-table
#+BEGIN_SRC emacs-lisp
;;; org-drill-table.el --- Generate drill cards from org tables

;; Copyright (C) 2014 Chris Barrett

;; Author: Chris Barrett <chris.d.barrett@me.com>
;; Package-Requires: ((s "1.7.0") (dash "2.2.0") (cl-lib "0.3") (org "8.2") (emacs "24.1"))
;; Version: 0.1.1

;; This file is not part of GNU Emacs.

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Generate drill cards from org tables.

;; org-drill requires individual headlines with the "drill" tag; creating these
;; can be laborious and it is difficult to get an overview of your cards when
;; the buffer is folded.

;; This package provides a command, `org-drill-table-generate', that will
;; generate drill cards based on an org-mode table in the current subtree. The
;; cards will inserted under a new "Cards" heading in the current tree.

;; For example, given the following org headline,

;;    * Vocab
;;    |-----------+---------+----------------|
;;    | English   | Spanish | Example        |
;;    |-----------+---------+----------------|
;;    | Today     | Hoy     | Hoy es domingo |
;;    | Yesterday | Ayer    |                |
;;    | Tomorrow  | Mañana  |                |
;;    |-----------+---------+----------------|

;; invoking `org-drill-table-generate' will generate cards for each table row:

;;    * Vocab
;;    :PROPERTIES:
;;    :DRILL_HEADING:
;;    :DRILL_CARD_TYPE: twosided
;;    :DRILL_INSTRUCTIONS: Translate the following word.
;;    :END:
;;    |-----------+---------+----------------|
;;    | English   | Spanish | Example        |
;;    |-----------+---------+----------------|
;;    | Today     | Hoy     | Hoy es domingo |
;;    | Yesterday | Ayer    |                |
;;    | Tomorrow  | Mañana  |                |
;;    |-----------+---------+----------------|
;;    ** Cards
;;    *** Today                                                          :drill:
;;    :PROPERTIES:
;;    :DRILL_CARD_TYPE: twosided
;;    :END:
;;    Translate the following word.
;;    **** English
;;    Today
;;    **** Spanish
;;    Hoy
;;    **** Example
;;    Hoy es domingo
;;    *** Yesterday                                                      :drill:
;;    :PROPERTIES:
;;    :DRILL_CARD_TYPE: twosided
;;    :END:
;;    Translate the following word.
;;    **** English
;;    Yesterday
;;    **** Spanish
;;    Ayer
;;    *** Tomorrow                                                       :drill:
;;    :PROPERTIES:
;;    :DRILL_CARD_TYPE: twosided
;;    :END:
;;    Translate the following word.
;;    **** English
;;    Tomorrow
;;    **** Spanish
;;    Mañana
;;
;; Note that there are several things happening here:
;;   - Each column in the table is put on its own row if it's non-empty
;;   - Instead of using the DRILL_HEADING property as a generic heading, the first element of each row is used as the heading

;;
;; If instead of using the words from the first column as the headings, you want to use the same string for each heading,
;; (i.e. the old behavior) this can be done by specifying the DRILL_HEADING property
;;
;; `org-drill-table-generate' checks the existing list of cards so it does not
;; add duplicates.

;; This package provides an additional command, `org-drill-table-update', which
;; can be added to `org-ctrl-c-ctrl-c-hook'.

;;; Code:

(require 'dash)
(require 's)
(require 'cl-lib)
(require 'org)
(require 'org-drill nil t)

(defgroup org-drill-table nil
  "Generate drill cards from org tables."
  :group 'org
  :prefix "org-drill-table")

(defcustom org-drill-table-noexport-cards t
  "When non-nil, apply :noexport: tag to generated Cards."
  :group 'org-drill-table
  :type 'boolean)

;; -----------------------------------------------------------------------------

;; Silence byte-compiler warning.
(defvar org-drill-card-type-alist nil)


(cl-defstruct (OrgDrillCard
               (:constructor OrgDrillCard (heading type instructions subheadings)))
  "Defines a card to generate for use with org-drill.

  HEADING is the headline for the card.

  TYPE is a string, which should be one of the valid values of
  DRILL_CARD_TYPE.

  INSTRUCTIONS is a short string describing how to complete this
  card.

  SUBHEADINGS is an alist of (\"header\" . \"body\")."
  heading type instructions subheadings)

(defun org-drill-table--drill-table-rows ()
  "Extract the rows from the table at point.
Return a list of rows, where each row a cons of the column name
and the row value."
  (cl-destructuring-bind
      (header &rest body) (--remove (equal 'hline it) (org-table-to-lisp))
    (->> body
         (--map (-zip-with 'cons header it))
         (--map (-remove (lambda (x) (string= "" (cdr x))) it)))))

(defun org-drill-table--goto-table-in-subtree ()
  "Move to the first table in the current subtree."
  (let ((bound (save-excursion (outline-next-heading) (point))))
    (search-forward-regexp (rx bol "|") bound t)))

(defun org-drill-table--insert-card (card)
  "Insert an OrgDrillCard CARD into the current buffer."
  (insert (OrgDrillCard-heading card))
  (org-set-tags-to ":drill:")
  (goto-char (line-end-position))
  (newline)
  (org-set-property "DRILL_CARD_TYPE" (OrgDrillCard-type card))
  (insert (OrgDrillCard-instructions card))
  ;; Insert subheadings. Create a subheading for the first and use the same
  ;; heading level for the rest.
  (--each (-map-indexed 'cons (OrgDrillCard-subheadings card))
    (cl-destructuring-bind (idx header . value) it
      (if (zerop idx) (org-insert-subheading nil) (org-insert-heading))
      (insert header)
      (newline)
      (insert value))))

(defun org-drill-table--skip-props-and-schedule ()
  "Move past the properties and schedule of the current subtree."
  ;; Properties.
  (-when-let (bounds (org-get-property-block))
    (goto-char (cdr bounds))
    (forward-line))
  ;; Schedule.
  (when (s-matches? "SCHEDULED" (buffer-substring (line-beginning-position)
                                                  (line-end-position)))
    (forward-line))
  ;; Advance point if we're still on an org-heading. This is required because
  ;; if the sub-heading has no properties or scheduled, then point won't move
  (when (org-at-heading-p)
    (forward-line)))

(defun org-drill-table--subtree->card ()
  "Convert an individual drill card at point to an OrgDrillCard."
  (let ((heading (elt (org-heading-components) 4))
        (type (org-entry-get (point) "DRILL_CARD_TYPE")))
    (save-excursion
      (save-restriction
        (org-narrow-to-subtree)
        (org-drill-table--skip-props-and-schedule)

        ;; Instructions are the rest of the text up to the first child.
        (let ((instructions
               (s-trim
                (buffer-substring-no-properties
                 (point)
                 (save-excursion
                   (outline-next-heading)
                   (1- (point)))))))

          ;; Get an alist of headings to content.
          (let (acc)
            (while (outline-next-heading)
              (let ((hd (elt (org-heading-components) 4))
                    (content (save-restriction
                               (org-narrow-to-subtree)
                               (org-drill-table--skip-props-and-schedule)
                               (s-trim (buffer-substring-no-properties (point) (point-max))))))
                (setq acc (cons (cons hd content) acc))))

            (OrgDrillCard heading type instructions (nreverse acc))))))))

(defun org-drill-table--forward-heading-until-at-cards ()
  "Move forward by headings at this level until the Cards heading is found."
  (save-restriction
    (org-narrow-to-subtree)
    (unless (org-at-heading-p) (outline-next-heading))
    (let ((moved? t)
          (cards-heading-pos nil))
      (while (and moved? (not cards-heading-pos))
        (let ((before (point)))
          (org-forward-heading-same-level nil t)
          (setq moved? (/= before (point)))
          (when (s-matches? (rx bol (+ "*") (+ space) "Cards")
                            (buffer-substring (line-beginning-position)
                                              (line-end-position)))
            (setq cards-heading-pos (point)))))

      cards-heading-pos)))

(defun org-drill-table--goto-or-insert-cards-heading ()
  "Move to the Cards heading for the current subtree.
Create the heading if it does not exist."
  (save-restriction
    (org-narrow-to-subtree)
    (let ((subtrees? (save-excursion (outline-next-heading)))
          (found? (org-drill-table--forward-heading-until-at-cards)))
      (unless found?
        (goto-char (point-max))
        (if subtrees? (org-insert-heading) (org-insert-subheading nil))
        (insert "Cards")
        (when org-drill-table-noexport-cards
          (org-set-tags-to ":noexport:"))))
    (goto-char (line-end-position))))

(defun org-drill-table--existing-cards ()
  "Parse the Cards subtree for existing drill cards.
Return a list of OrgDrillCard."
  (save-excursion
    (when (org-drill-table--forward-heading-until-at-cards)
      (save-restriction
        (org-narrow-to-subtree)
        (let (acc)
          (while (outline-next-heading)
            (setq acc (cons (org-drill-table--subtree->card) acc)))
          (nreverse acc))))))

(defun org-drill-table--table->cards (heading type instructions)
  "Convert the drill-table tree at point to a list of OrgDrillCards. "
  (--map (OrgDrillCard
          (if (string= "" heading)
              (cdr (car it)) heading)
          type instructions it)
         (org-drill-table--drill-table-rows)))

(defun org-drill-table--get-or-read-prop (name read-fn)
  "Get the value of property NAME for the headline at point.
If the property is not set, read from the user using READ-FN."
  (or (org-entry-get (point) name)
      (let ((val (funcall read-fn)))
        (org-entry-put (point) name val)
        val)))

;;;###autoload
(defun org-drill-table-generate (heading type instructions)
  "Use a table at the current heading to generate org-drill cards.

HEADING is the title to use for each card.

TYPE is a string, of one of the card types in `org-drill-card-type-alist'.

INSTRUCTIONS is a string describing how to use the card."
  (interactive
   (list
    (org-drill-table--get-or-read-prop
     "DRILL_HEADING" (lambda () (read-string "Card heading: ")))
    (org-drill-table--get-or-read-prop
     "DRILL_CARD_TYPE"
     (lambda ()
       (completing-read "Type: "
                        (-keep 'car org-drill-card-type-alist)
                        nil
                        t
                        "twosided")))
    (org-drill-table--get-or-read-prop
     "DRILL_INSTRUCTIONS" (lambda () (read-string "Card instructions: ")))))

  (unless (org-at-table-p)
    (org-drill-table--goto-table-in-subtree))

  (let* ((cards (org-drill-table--table->cards heading type instructions))
         (existing (org-drill-table--existing-cards))
         (new-cards (-difference cards existing)))
    (save-excursion
      (org-drill-table--goto-or-insert-cards-heading)
      ;; Find only cards that have not been inserted.
      (--each (-map-indexed 'cons new-cards)
        ;; Insert each tree, retaining the current heading level.
        (cl-destructuring-bind (idx . card) it
          (org-insert-subheading nil)
          (unless (zerop idx)
            (org-promote-subtree)
            (org-promote-subtree))

          (org-drill-table--insert-card card))))

    (let ((len (length new-cards)))

      (if (zerop len)
          (when (called-interactively-p nil)
            (message "No new cards to insert"))
        (org-align-all-tags)
        (when (called-interactively-p nil)
          (message "Inserted %s new card%s"
                   len
                   (if (= 1 len) "" "s")))))))

;;;###autoload
(defun org-drill-table-update ()
  "Update an existing org drill table.
Suitable for adding to `org-ctrl-c-ctrl-c-hook'."
  (interactive "*")
  (when (and (org-at-table-p)
             (org-entry-get (point) "DRILL_HEADING"))
    (call-interactively 'org-drill-table-generate)))

;;;###autoload
(defun org-drill-table-update-all ()
  "Call `org-drill-table-update' on each table in the buffer."
  (interactive "*")
  (org-table-map-tables 'org-drill-table-update))

(provide 'org-drill-table)

;;; org-drill-table.el ends here
#+END_SRC
** Making ispell work with org-mode
http://endlessparentheses.com/ispell-and-org-mode.html

#+BEGIN_SRC emacs-lisp
(defun endless/org-ispell ()
  "Configure `ispell-skip-region-alist' for `org-mode'."
  (make-local-variable 'ispell-skip-region-alist)
  (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
  (add-to-list 'ispell-skip-region-alist '("~" "~"))
  (add-to-list 'ispell-skip-region-alist '("=" "="))
  (add-to-list 'ispell-skip-region-alist '("$" "$"))
  (add-to-list 'ispell-skip-region-alist '("\\[" "\\]"))
  (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC" . "^#\\+END_SRC")))
(add-hook 'org-mode-hook #'endless/org-ispell)
#+END_SRC
** Noter
#+BEGIN_SRC emacs-lisp
(use-package org-noter
  :ensure t)

(setq org-noter-property-doc-file "INTERLEAVE_PDF"
      org-noter-property-note-location "INTERLEAVE_PAGE_NOTE")
#+END_SRC
** Contacts
#+BEGIN_SRC emacs-lisp
(use-package org-contacts
  :after org
  :custom (org-contacts-files '("~/Dropbox/orgzly/Contacts.org")))
#+END_SRC

** Capture
From [[https://www.reddit.com/r/emacs/comments/8toivy/tip_how_to_manage_your_contacts_with_orgcontacts/][this post]].

#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)

(defvar m42/org-contacts-template "* %^{name}
:PROPERTIES:
:BIRTHDAY: %^{yyyy-mm-dd}
:EMAIL: %^{email}
:NOTE: %^{NOTE}
:END:" "Template for org-contacts.")

  (setq org-capture-templates (quote (
    ("j" "Journal" entry (file m42/journal-file)
      "* %(shell-command-to-string \"date\")%?")
    ("c" "Contact" entry (file+headline "~/Dropbox/orgzly/Contacts.org" "Inbox")
      "* %^{Name}
:PROPERTIES:
:EMAIL: %^{Email}
:BIRTHDAY: %^{yyyy-mm-dd}
:NOTE: %^{Note}
:END:"
      :empty-lines 1))))
#+END_SRC

** DISABLED Gcalendar
Initial configuration, using the Google API. Follows [[https://cestlaz.github.io/posts/using-emacs-26-gcal/#.WNpulq2xVhE][this tutorial by C'est la Z]].

#+BEGIN_SRC emacs-lisp
  ;; (use-package org-gcal
  ;;   :ensure t
  ;;   :config
  ;;   (setq org-gcal-client-id "139081640689-4njrqlrlidldfo9j0s8vp20qrgvbr06g.apps.googleusercontent.com"
  ;; 	org-gcal-client-secret m42/gcal-client-secret
  ;; 	org-gcal-file-alist '(("mromang08@gmail.com" . "~/org/wiki/calendar.org"))))
#+END_SRC

Hooks for synchronization.

#+BEGIN_SRC emacs-lisp
; (add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync)))
; (add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-sync)))
#+END_SRC

** DISABLED Tasks & To-read
Following the advice of [[https://rafaelleru.github.io/2017/01/22/to_read_list_emacs/][@rafaelleru]].

#+BEGIN_SRC emacs-lisp
;  (defun m42/export-html-if-agenda()
;    "Auto exports an html file"
;    (when (equal buffer-file-name m42/links-file)
;      (org-twbs-export-to-html)))
;
;  (add-hook 'after-save-hook 'm42/export-html-if-agenda)
#+END_SRC

* Snippets
** Yasnippet support
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :init (add-to-list 'load-path "~/.emacs.d/plugins/yasnippet")
    :config (yas-global-mode 1)
    :bind (("<C-dead-grave>" . yas-insert-snippet))
    )
#+END_SRC

** Snippets for programming languages
#+BEGIN_SRC emacs-lisp
  (use-package haskell-snippets
    :ensure t)
#+END_SRC
** Yankpad
[[https://github.com/Kungsgeten/yankpad][Yankpad]] provides a simpler way of managing snippets within an
org-mode file. Snippets are stored in the =yankpad-file=, which
in my case is [[file:yankpad.org][this]] file.

 * Snippets can be inserted with =yankpad-insert=.
 * Current category of snippets can be set with =yankpad-capture=.
 * Snippets can be added to the current category using
   =yankpad-capture=.

#+BEGIN_SRC emacs-lisp
  (use-package yankpad
    :ensure t
    :defer 10
    :init (setq yankpad-file "~/.emacs.d/yankpad.org")
    :bind (("M-ñ" . yankpad-insert))
  )
#+END_SRC

* Social
** RSS
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure t)

  (use-package elfeed-org
    :ensure t
    :init
      (setq rhm-elfeed-org-files (list "~/Dropbox/orgzly/Elfeed.org"))
    :config
      (elfeed-org))

  (use-package elfeed-goodies
    :ensure t)

  (set-face-attribute 'variable-pitch nil
     :font "Iosevka")
#+END_SRC

** Mastodon
[[https://en.wikipedia.org/wiki/Mastodon_(software)][Mastodon]] is a free software federated social network. A specific
[[https://github.com/jdenen/mastodon.el][mastodon-mode]] was written by Johnson Denen (@jdenen).

#+BEGIN_SRC emacs-lisp
(use-package mastodon
  :config (setq mastodon-instance-url "https://mastodon.social")
  :ensure t)
#+END_SRC

** Stackoverflow
#+BEGIN_SRC emacs-lisp
(use-package sx
  :ensure t
  :config
  (bind-keys :prefix "C-c s"
             :prefix-map my-sx-map
             :prefix-docstring "Global keymap for SX."
             ("q" . sx-tab-all-questions)
             ("i" . sx-inbox)
             ("o" . sx-open-link)
             ("u" . sx-tab-unanswered-my-tags)
             ("a" . sx-ask)
             ("s" . sx-search)))
#+END_SRC

** DISABLED Wikipedia
#+BEGIN_SRC emacs-lisp
  ;; (use-package mediawiki
  ;;   :ensure t)

  ;; (setq mediawiki-site-alist
  ;;       (append '(("ArchWiki" "https://wiki.archlinux.org/" "username" "password" "Main page"))
  ;;               mediawiki-site-alist))
#+END_SRC

* Utilities
** Internet
#+BEGIN_SRC emacs-lisp
(defun m42/wifi-off ()
  (interactive)
  (shell-command "nmcli r wifi off"))
(defun m42/wifi-on ()
  (interactive)
  (shell-command "nmcli r wifi on"))
#+END_SRC
** Pomodoro+orgnoter+wifioff
#+BEGIN_SRC emacs-lisp
(defun m42/pomodoro ()
  (interactive)
;  (org-noter)
  (org-clock-in)
  (m42/wifi-off)
  )
(defun m42/pomodoro-end ()
  (interactive)
  (org-clock-out)
  (m42/wifi-on)
  )
#+END_SRC

** Ledger
#+BEGIN_SRC emacs-lisp
(use-package ledger-mode
  :ensure t)
#+END_SRC

* DISABLED EXWM
#+BEGIN_SRC emacs-lisp
;(use-package exwm
;  :ensure t)
;
;(use-package exwm-edit
;  :ensure t)
;
;(require 'exwm-config)
;(exwm-config-default)
#+END_SRC


** Desktop-environment
#+BEGIN_SRC emacs-lisp
;(use-package desktop-environment
;  :ensure t)
;(desktop-environment-mode)
#+END_SRC
