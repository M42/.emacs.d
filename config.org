#+TITLE: config.org
#+AUTHOR: Mario Román
#+EMAIL: mromang08@gmail.com
#+TODO: DISABLED WIP | DONE

This is my Emacs init file, written in org-mode using literate
programming and =org-babel= blocks. The =init.el= file tangles the
Elisp code blocks of this file into =config.el=. I have taken ideas
for my configuration mainly from

  - [[http://cestlaz.github.io/][C'est la Z]]
  - [[https://github.com/hrs/dotfiles/blob/master/emacs.d/configuration.org][Harry R. Schwartz's configuration file]]

and from many other configuration files and blogs such as

  - [[http://emacsredux.com/][Emacs Redux]]
  - [[http://irreal.org/blog/][Irreal]]
  - [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's configuration file]]
  - [[http://karl-voit.at/2017/06/03/emacs-org/][Karl Voit's configuration file]]

It /works for me/ on Emacs 26.0.50 and org-version 9.0.9. You can check
your Emacs version with =M-x version= and your org-mode version with
=M-x org-version=.

* Basic
** Personal information
[[https://www.gnu.org/software/emacs/manual/html_node/elisp/User-Identification.html][User information]] used by Emacs in frame titles and email.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Mario Román"
      user-mail-address "mromang08@gmail.com")
#+END_SRC

Sensitive information is stored into a different file which I do not
upload to GitHub. It sets some variables.

#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/emacs.secrets" t)
#+END_SRC

** Files
A list of the most important files on my workflow. Those variables are
used all across the configuration file; and listing them here eases
the process of rewriting directory paths.

#+BEGIN_SRC emacs-lisp
  (setq m42/index-file      (expand-file-name "~/org/wiki/index.org"))
  (setq m42/wiki-file       (expand-file-name "~/org/wiki/wiki.org"))
  (setq m42/math-index-file (expand-file-name "~/projects/math/index.org"))
  (setq m42/math-file       (expand-file-name "~/projects/math/notes.org"))
  (setq m42/tfg-file        (expand-file-name "~/projects/math/tfg.org"))
  (setq m42/math-drill-file (expand-file-name "~/projects/math/drill.org"))
  (setq m42/links-file      (expand-file-name "~/org/wiki/links.org"))
  (setq m42/init-file       (expand-file-name "~/.emacs.d/config.org"))
  (setq m42/agenda-file     (expand-file-name "~/org/wiki/tasks.org"))
  (setq m42/calendar-file   (expand-file-name "~/org/wiki/calendar.org"))
  (setq m42/ideas-file      (expand-file-name "~/org/wiki/ideas.org"))
  (setq m42/bugs-file       (expand-file-name "~/org/wiki/bugs.org"))
  (setq m42/file-archive    (expand-file-name "~/org/archive.org"))
  (setq m42/org-folder      (expand-file-name "~/org"))

  (global-set-key (kbd "<f5>") (lambda() (interactive) (find-file m42/index-file)))
  (global-set-key (kbd "<f6>") (lambda() (interactive) (find-file m42/tfg-file)))
  (global-set-key (kbd "<f7>") (lambda() (interactive) (find-file m42/math-index-file)))
  (global-set-key (kbd "<f8>") (lambda() (interactive) (find-file m42/init-file)))
  (global-set-key (kbd "<f9>") (lambda() (interactive) (find-file m42/agenda-file)))

  (setq org-agenda-files (list m42/agenda-file m42/calendar-file))
#+END_SRC

*** Local bin
Includes the local bin on the =exec-path=. This allows Emacs to find executables
between the local binaries.

#+BEGIN_SRC emacs-lisp
(setq exec-path (cons "/home/mario/.local/bin" exec-path))
#+END_SRC

** Initial buffer
Inhibits the startup screen and loads an initial buffer.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
(setq initial-buffer-choice m42/init-file)
#+END_SRC

** Reload init.el
The configuration files can be reloaded at any time using =M-insert=.
This eases the process of writing, debugging and testing the
configuration file. Current set variables will not be removed; and
Emacs will need a complete restart to clean them.

#+BEGIN_SRC emacs-lisp
(global-set-key [M-insert] '(lambda() (interactive) (load-file "~/.emacs.d/init.el")))
#+END_SRC

** Restart emacs
[[https://github.com/iqbalansari/restart-emacs][Restart-emacs]] is a package to restart Emacs from within Emacs. It
offers the command =restart-emacs=, which kills the current Emacs
session and starts a new session.

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :ensure t)
#+END_SRC

** Better defaults
#+BEGIN_SRC emacs-lisp
(use-package better-defaults
  :ensure t)
#+END_SRC
** Backup files
Disables backup files.

#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
#+END_SRC

** Shell
Starts shell using =C-c s=.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c s") 'eshell)
#+END_SRC

** Smex
[[https://www.emacswiki.org/emacs/Smex][Smex]] provides an enhancement to the =M-x= command. Uses =ido= for
autocompletion and provides a convenient interface to the most
frequently used commands.

#+BEGIN_SRC emacs-lisp
(use-package smex
  :ensure t
  :config (smex-initialize)
  :bind (("M-x" . smex)))
#+END_SRC

** Switching windows with ctrl+tab
It is possible to change windows in Emacs using =C-x o=, but
sometimes =C-tab= still feels more intuitive to me.

#+BEGIN_SRC emacs-lisp
(global-set-key [C-tab] 'other-window)
(global-set-key [C-iso-lefttab]
  (lambda ()
    (interactive)
    (other-window -1)))
#+END_SRC

** Multiple cursors
#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         )
)
#+END_SRC
* Customization
** Theme
Uses the [[https://github.com/bbatsov/zenburn-emacs][Zenburn color theme]], which is a dark, low-contrast theme
ported from Vim. It also loads the [[https://github.com/jasonblewis/color-theme-wombat][Wombat theme]], also a dark theme
ported from Vim.

#+BEGIN_SRC emacs-lisp
; Zenburn theme
(use-package zenburn-theme
  :ensure t)

; Wombat theme
(load-theme 'wombat t)
#+END_SRC

** Toolbar and menubar
Disable the toolbar and menubar

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
(tooltip-mode -1)
#+END_SRC

** Cursor
Cursor should not blink

#+BEGIN_SRC emacs-lisp
(setq blink-cursor-mode nil)
#+END_SRC

** Yes-no to y-n
Yes-no questions are unnecessarily long.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Word wrapping and selection mode
#+BEGIN_SRC emacs-lisp
(setq-default word-wrap 1)
(delete-selection-mode 1)
#+END_SRC

** Custom file
Loads the customize file, follows this [[http://emacsblog.org/2008/12/06/quick-tip-detaching-the-custom-file/][article]]:

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file 'noerror)
#+END_SRC

** What face?
Indicates what face are we using currently under the cursor.

#+BEGIN_SRC emacs-lisp
  (defun what-face (pos)
    (interactive "d")
    (let ((face (or (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face))))
      (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+END_SRC

** Swiper
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  )

(use-package swiper
  :ensure t
  :config
  (progn
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (global-set-key "\C-s" 'swiper)
    (global-set-key (kbd "C-c r") 'ivy-resume)
    ;(global-set-key (kbd "<f6>") 'ivy-resume)
    (global-set-key (kbd "M-x") 'counsel-M-x)
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (global-set-key (kbd "<f1> f") 'counsel-describe-function)
    (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
    (global-set-key (kbd "<f1> l") 'counsel-load-library)
    (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
    (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
    (global-set-key (kbd "C-c g") 'counsel-git)
    (global-set-key (kbd "C-c j") 'counsel-git-grep)
    (global-set-key (kbd "C-c k") 'counsel-ag)
    (global-set-key (kbd "C-x l") 'counsel-locate)
    (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
    (define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
    ))
#+END_SRC

** Which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config (which-key-mode))
#+END_SRC

* Programming
** Flycheck
Flycheck checks the syntax of programming languages.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))
#+END_SRC

** Magit
[[https://magit.vc/][Magit]] is an interface to the version control system [[https://git-scm.com/][Git]]. The main
function is =magit-status=, which shows the status of the files on the
current repository.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-c g" . magit-status)
    )
#+END_SRC

** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config
  (projectile-global-mode)
(setq projectile-completion-system 'ivy))

(use-package counsel-projectile
  :ensure t
  :config
  (counsel-projectile-on))
#+END_SRC

** Haskell
Allows interactive Haskell evaluation in Emacs.

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t)
  (require 'haskell-interactive-mode)
  (require 'haskell-process)
  (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
#+END_SRC

*** Intero
#+BEGIN_SRC emacs-lisp
(use-package flycheck-haskell
  :ensure t)

(use-package intero
  :ensure t)
(add-hook 'haskell-mode-hook 'intero-mode)

(with-eval-after-load 'intero
  (with-eval-after-load 'flycheck 
    (flycheck-add-next-checker 'intero '(warning . haskell-hlint))))
#+END_SRC

*** Hindent
**** hindent.el
#+BEGIN_SRC emacs-lisp
;;; hindent.el --- Indent haskell code using the "hindent" program

;; Copyright (c) 2014 Chris Done. All rights reserved.

;; Author: Chris Done <chrisdone@gmail.com>
;; URL: https://github.com/chrisdone/hindent
;; Package-Requires: ((cl-lib "0.5"))

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; Provides a minor mode and commands for easily using the "hindent"
;; program to reformat Haskell code.

;; Add `hindent-mode' to your `haskell-mode-hook' and use the provided
;; keybindings as needed.  Set `hindent-reformat-buffer-on-save' to
;; `t' globally or in local variables to have your code automatically
;; reformatted.

;;; Code:

(require 'cl-lib)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Customization properties

(defgroup hindent nil
  "Integration with the \"hindent\" reformatting program."
  :prefix "hindent-"
  :group 'haskell)

(defcustom hindent-style
  nil
  "The style to use for formatting.

For hindent versions lower than 5, you must set this to a non-nil string."
  :group 'hindent
  :type 'string
  :safe #'stringp)

(make-obsolete-variable 'hindent-style nil "hindent 5")


(defcustom hindent-process-path
  "hindent"
  "Location where the hindent executable is located."
  :group 'hindent
  :type 'string
  :safe #'stringp)

(defcustom hindent-reformat-buffer-on-save nil
  "Set to t to run `hindent-reformat-buffer' when a buffer in `hindent-mode' is saved."
  :group 'hindent
  :type 'boolean
  :safe #'booleanp)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Minor mode

(defvar hindent-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map [remap indent-region] #'hindent-reformat-region)
    (define-key map [remap fill-paragraph] #'hindent-reformat-decl-or-fill)
    map)
  "Keymap for `hindent-mode'.")

;;;###autoload
(define-minor-mode hindent-mode
  "Indent code with the hindent program.

Provide the following keybindings:

\\{hindent-mode-map}"
  :init-value nil
  :keymap hindent-mode-map
  :lighter " HI"
  :group 'hindent
  :require 'hindent
  (if hindent-mode
      (add-hook 'before-save-hook 'hindent--before-save nil t)
    (remove-hook 'before-save-hook 'hindent--before-save t)))

(defun hindent--before-save ()
  "Optionally reformat the buffer on save."
  (when hindent-reformat-buffer-on-save
    (hindent-reformat-buffer)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Interactive functions

;;;###autoload
(defun hindent-reformat-decl ()
  "Re-format the current declaration.

The declaration is parsed and pretty printed.  Comments are
preserved, although placement may be funky."
  (interactive)
  (let ((start-end (hindent-decl-points)))
    (when start-end
      (let ((beg (car start-end))
            (end (cdr start-end)))
        (hindent-reformat-region beg end t)))))

;;;###autoload
(defun hindent-reformat-buffer ()
  "Reformat the whole buffer."
  (interactive)
  (hindent-reformat-region (point-min)
                           (point-max)))

;;;###autoload
(defun hindent-reformat-decl-or-fill (justify)
  "Re-format current declaration, or fill paragraph.

Fill paragraph if in a comment, otherwise reformat the current
declaration.  When filling, the prefix argument JUSTIFY will
cause the text to be justified, as per `fill-paragraph'."
  (interactive (progn
                 ;; Copied from `fill-paragraph'
                 (barf-if-buffer-read-only)
                 (list (if current-prefix-arg 'full))))
  (if (hindent-in-comment)
      (fill-paragraph justify t)
    (hindent-reformat-decl)))

;;;###autoload
(defun hindent-reformat-region (beg end &optional drop-newline)
  "Reformat the region from BEG to END, accounting for indentation.

If DROP-NEWLINE is non-nil, don't require a newline at the end of
the file."
  (interactive "r")
  (if (= (save-excursion (goto-char beg)
                         (line-beginning-position))
         beg)
      (hindent-reformat-region-as-is beg end drop-newline)
    (let* ((column (- beg (line-beginning-position)))
           (string (buffer-substring-no-properties beg end))
           (new-string (with-temp-buffer
                         (insert (make-string column ? ) string)
                         (hindent-reformat-region-as-is (point-min)
                                                        (point-max)
                                                        drop-newline)
                         (delete-region (point-min) (1+ column))
                         (buffer-substring (point-min)
                                           (point-max)))))
      (save-excursion
        (goto-char beg)
        (delete-region beg end)
        (insert new-string)))))

;;;###autoload
(define-obsolete-function-alias 'hindent/reformat-decl 'hindent-reformat-decl)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Internal library

(defun hindent-reformat-region-as-is (beg end &optional drop-newline)
  "Reformat the given region from BEG to END as-is.

This is the place where hindent is actually called.

If DROP-NEWLINE is non-nil, don't require a newline at the end of
the file."
  (let* ((original (current-buffer))
         (orig-str (buffer-substring-no-properties beg end)))
    (with-temp-buffer
      (let ((temp (current-buffer)))
        (with-current-buffer original
          (let ((ret (apply #'call-process-region
                            (append (list beg
                                          end
                                          hindent-process-path
                                          nil ; delete
                                          temp ; output
                                          nil)
                                    (hindent-extra-arguments)))))
            (cond
             ((= ret 1)
              (let ((error-string
                     (with-current-buffer temp
                       (let ((string (progn (goto-char (point-min))
                                            (buffer-substring (line-beginning-position)
                                                              (line-end-position)))))
                         string))))
                (if (string= error-string "hindent: Parse error: EOF")
                    (message "language pragma")
                  (error error-string))))
             ((= ret 0)
              (let* ((last-decl (= end (point-max)))
                     (new-str (with-current-buffer temp
                                (when (and drop-newline (not last-decl))
                                  (goto-char (point-max))
                                  (when (looking-back "\n" (1- (point)))
                                    (delete-char -1)))
                                (buffer-string))))
                (if (not (string= new-str orig-str))
                    (let ((line (line-number-at-pos))
                          (col (current-column)))
                      (delete-region beg
                                     end)
                      (let ((new-start (point)))
                        (insert new-str)
                        (let ((new-end (point)))
                          (goto-char (point-min))
                          (forward-line (1- line))
                          (goto-char (+ (line-beginning-position) col))
                          (when (looking-back "^[ ]+" (line-beginning-position))
                            (back-to-indentation))
                          (delete-trailing-whitespace new-start new-end)))
                      (message "Formatted."))
                  (message "Already formatted.")))))))))))

(defun hindent-decl-points ()
  "Get the start and end position of the current declaration.

This assumes that declarations start at column zero and that the
rest is always indented by one space afterwards, so Template
Haskell uses with it all being at column zero are not expected to
work."
  (cond
   ;; If we're in a block comment spanning multiple lines then let's
   ;; see if it starts at the beginning of the line (or if any comment
   ;; is at the beginning of the line, we don't care to treat it as a
   ;; proper declaration.
   ((and (hindent-in-comment)
         (save-excursion (goto-char (line-beginning-position))
                         (hindent-in-comment)))
    nil)
   ((save-excursion
      (goto-char (line-beginning-position))
      (or (looking-at "^-}$")
          (looking-at "^{-$")))
    nil)
   ;; Otherwise we just do our line-based hack.
   (t
    (save-excursion
      (let ((start
             (or (cl-letf
                     (((symbol-function 'jump)
                       #'(lambda ()
                           (search-backward-regexp "^[^ \n]" nil t 1)
                           (cond
                            ((save-excursion (goto-char (line-beginning-position))
                                             (looking-at "|]"))
                             (jump))
                            (t (unless (or (looking-at "^-}$")
                                           (looking-at "^{-$"))
                                 (point)))))))
                   (goto-char (line-end-position))
                   (jump))
                 0))
            (end
             (progn
               (goto-char (1+ (point)))
               (or (cl-letf
                       (((symbol-function 'jump)
                         #'(lambda ()
                             (when (search-forward-regexp "[\n]+[^ \n]" nil t 1)
                               (cond
                                ((save-excursion (goto-char (line-beginning-position))
                                                 (looking-at "|]"))
                                 (jump))
                                (t (forward-char -1)
                                   (search-backward-regexp "[^\n ]" nil t)
                                   (forward-char)
                                   (point)))))))
                     (jump))
                   (point-max)))))
        (cons start end))))))

(defun hindent-in-comment ()
  "Are we currently in a comment?"
  (save-excursion
    (when (and (= (line-end-position)
                  (point))
               (/= (line-beginning-position) (point)))
      (forward-char -1))
    (and
     (elt (syntax-ppss) 4)
     ;; Pragmas {-# SPECIALIZE .. #-} etc are not to be treated as
     ;; comments, even though they are highlighted as such
     (not (save-excursion (goto-char (line-beginning-position))
                          (looking-at "{-# "))))))

(defun hindent-extra-arguments ()
  "Extra command line arguments for the hindent invocation."
  (append
   (when (boundp 'haskell-language-extensions)
     haskell-language-extensions)
   (when hindent-style
     (list "--style" hindent-style))))

(provide 'hindent)

;;; hindent.el ends here
#+END_SRC
**** Hook
#+BEGIN_SRC emacs-lisp
(add-hook 'haskell-mode-hook #'hindent-mode)
#+END_SRC
** Markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t)
#+END_SRC

** R
Emacs Speaks Statistics.

#+BEGIN_SRC emacs-lisp
(use-package ess
  :ensure t)

(require 'ess-site)
#+END_SRC

** Python
Elpy support.

#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t)
(elpy-enable)
(elpy-use-ipython)
(setq elpy-rpc-python-command "python2")
#+END_SRC

*** Jupyter notebook
#+BEGIN_SRC emacs-lisp
(use-package ein
  :ensure t)
#+END_SRC

** Agda
Loads the =agda-mode= configuration. Agda provides the location
of its configuration file with the command =agda-mode locate=.

#+BEGIN_SRC emacs-lisp
(load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "agda-mode locate")))
#+END_SRC

*** Customization
Little tweak on agda colors. Original blue was too dark.

#+BEGIN_SRC emacs-lisp
  (add-hook 'agda2-mode-hook
    (lambda ()
      (set-face-attribute 'agda2-highlight-record-face nil
        :foreground "light steel blue")))
#+END_SRC

** Sage
#+BEGIN_SRC emacs-lisp
  (use-package sage-shell-mode
    :ensure t)

  (setq sage-shell:use-prompt-toolkit t)
#+END_SRC

** Lisp
Evaluates Lisp in place with `C-c e`. Taken from [[http://emacsredux.com/blog/2013/06/21/eval-and-replace/][Emacs Redux]].

#+BEGIN_SRC emacs-lisp
  (defun eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))
  (global-set-key (kbd "C-c e") 'eval-and-replace)
#+END_SRC

** Latex
#+BEGIN_SRC emacs-lisp
  (use-package tex
    :ensure auctex)
#+END_SRC

*** Pdf generation process
#+BEGIN_SRC emacs-lisp
  (setq org-latex-pdf-process
	'("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %b"
          "bibtex %b"
          "makeindex %b"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %b"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %b"))
#+END_SRC

** Dot
#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
  :ensure t)
(setq default-tab-width 4)
#+END_SRC

** Proof General
Loads the Proof General file. Proof General can be installed directly
from AUR.

#+BEGIN_SRC emacs-lisp
(load "/usr/share/emacs/site-lisp/ProofGeneral/generic/proof-site")
#+END_SRC

** DISABLED HAML
HAML support.

#+BEGIN_SRC emacs-lisp
  ;; (use-package haml-mode
  ;;   :ensure t)

  ;; (add-hook 'haml-mode-hook
  ;;           (lambda ()
  ;;             (setq indent-tabs-mode nil)
  ;;             (define-key haml-mode-map "\C-m" 'newline-and-indent)))
#+END_SRC
** DISABLED Completion
Taken from [[https://github.com/malb/emacs.d/blob/master/malb.org#latex][malb's emacs.d]].

#+BEGIN_SRC emacs-lisp
  ;; (use-package company
  ;;   :ensure t
  ;;   :config (progn
  ;; 	    (global-company-mode 1)))
#+END_SRC

I am no longer using company-auctex.

#+BEGIN_SRC emacs-lisp
  ;; (use-package company-auctex
  ;;   :ensure t
  ;;   :config (progn
  ;;             (defun company-auctex-labels (command &optional arg &rest ignored)
  ;; 	      "company-auctex-labels backend"
  ;; 	      (interactive (list 'interactive))
  ;; 	      (case command
  ;;                 (interactive (company-begin-backend 'company-auctex-labels))
  ;;                 (prefix (company-auctex-prefix "\\\\.*ref{\\([^}]*\\)\\="))
  ;;                 (candidates (company-auctex-label-candidates arg))))

  ;;             (add-to-list 'company-backends
  ;;                          '(company-auctex-macros
  ;;                            company-auctex-environments))

  ;;             (add-to-list 'company-backends #'company-auctex-labels)
  ;;             (add-to-list 'company-backends #'company-auctex-bibs)))
#+END_SRC
* Translation
** Google translate
#+BEGIN_SRC emacs-lisp
(use-package google-translate
  :ensure t)

(require 'google-translate)
(require 'google-translate-default-ui)
(global-set-key "\C-ct" 'google-translate-at-point)
(global-set-key "\C-cT" 'google-translate-query-translate)

(setq google-translate-default-source-language "en")
(setq google-translate-default-target-language "es")
#+END_SRC

* Org-mode
** org-contrib and modules
#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure org-plus-contrib
  :config (define-key org-mode-map (kbd "C-<tab>") nil))

;; List of modules
(add-to-list 'org-modules "org-drill")
(add-to-list 'org-modules "org-bbdb")
(add-to-list 'org-modules "org-bibtex")
(add-to-list 'org-modules "org-docview")
(add-to-list 'org-modules "org-gnus")
(add-to-list 'org-modules "org-habit")
(add-to-list 'org-modules "org-info")
(add-to-list 'org-modules "org-irc")
(add-to-list 'org-modules "org-mhe")
(add-to-list 'org-modules "org-protocol")
(add-to-list 'org-modules "org-rmail")
(add-to-list 'org-modules "org-w3m")

(require 'org-drill)
(require 'org-habit)
#+END_SRC

** org-habit
#+BEGIN_SRC emacs-lisp
(setq org-habit-show-habits-only-for-today t)
#+END_SRC

** org-ref
#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :ensure t)

(setq org-ref-default-bibliography '("~/projects/math/math.bib"))
#+END_SRC

** org-refile
From [[https://www.reddit.com/r/emacs/comments/4366f9/how_do_orgrefiletargets_work/czg008y/][this reddit comment]].

#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((nil :maxlevel . 2)
                                (org-agenda-files :maxlevel . 9)))
(setq org-outline-path-complete-in-steps nil)         ; Refile in a single go
(setq org-refile-use-outline-path t)                  ; Show full paths for refiling
#+END_SRC

*** archive
Stores org files in =~/org=. Defines location of index, agenda and todo files.

#+BEGIN_SRC emacs-lisp
  (setq org-directory m42/org-folder)
  (setq org-archive-location (concat m42/file-archive "::* From %s"))
#+END_SRC

** org-agenda
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
	'(("c" "Complete agenda and todo"
           ((agenda "")
            (tags-todo "-habit")
            ))
            ))
#+END_SRC

** Keybindings
*** org-agenda and org-capture
Basic keybindings for org-mode.

#+BEGIN_SRC emacs-lisp
  (setq org-export-coding-system 'utf-8)
  (global-set-key "\C-cl" 'org-store-link)
  (global-set-key "\C-ca" 'org-agenda)
  (global-set-key "\C-cc" 'org-capture)
  (global-set-key "\C-cb" 'org-iswitchb)
#+END_SRC

*** Navigation
Navigation between headings.

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 
            (lambda ()
              (local-set-key "\M-n" 'outline-next-visible-heading)
              (local-set-key "\M-p" 'outline-previous-visible-heading)))
#+END_SRC

** org-mode customization
Sets attributes for the standard org-mode faces.

*** org-pretty-entities
#+BEGIN_SRC emacs-lisp
(setq org-pretty-entities t)
#+END_SRC

*** org-bullets
#+BEGIN_SRC emacs-lisp
  ;; Org-bullets
  (use-package org-bullets
    :ensure t)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

*** Indentation
#+BEGIN_SRC emacs-lisp
  ;; Indentation
  (setq org-startup-indented t)
#+END_SRC

*** Faces
#+BEGIN_SRC emacs-lisp
  ;; Faces
  (set-face-attribute 'org-level-1 nil
     :inherit 'outline-1
     :weight 'bold
     :height 1.05)

  (set-face-attribute 'org-level-2 nil
    :inherit 'outline-1
    :weight 'semi-bold
    :height 1.0)

  (set-face-attribute 'org-level-3 nil 
    :inherit 'outline-3 
    :weight 'bold)

  (set-face-attribute 'org-level-4 nil
    :inherit 'outline-3 
    :foreground "light steel blue" 
    :weight 'normal)

  (set-face-attribute 'org-level-5 nil
    :inherit 'outline-4 
    :foreground "thistle" 
    :weight 'normal)

  (set-face-attribute 'org-level-6 nil
    :inherit 'outline-4)

  (set-face-attribute 'org-level-8 nil
    :inherit 'outline-7)

  (set-face-attribute 'org-link nil
    :inherit 'link
;    :foreground "SlateGray1"
    :weight 'normal
    :underline nil)
#+END_SRC

** org-export
*** Beamer
Exports to beamer. Defines the beamer class.

#+BEGIN_SRC emacs-lisp
  (require 'ox-latex)
  (add-to-list 'org-latex-classes
               '("beamer"
                 "\\documentclass\[presentation\]\{beamer\}"
                 ("\\section\{%s\}" . "\\section*\{%s\}")
                 ("\\subsection\{%s\}" . "\\subsection*\{%s\}")
                 ("\\subsubsection\{%s\}" . "\\subsubsection*\{%s\}")))
#+END_SRC

*** Reveal.js
The configuration allowing me to do *Reveal.js* presentations using org-mode.
This was taken from [[http://cestlaz.github.io/posts/using-emacs-11-reveal][C'est la Z]].

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :ensure ox-reveal)

  (setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
  (setq org-reveal-mathjax t)

  (use-package htmlize
    :ensure t)
#+END_SRC

*** Bootstrap
#+BEGIN_SRC emacs-lisp
  (use-package ox-twbs
    :ensure ox-twbs)
#+END_SRC
*** Export all
#+BEGIN_SRC emacs-lisp
(defun m42/org-export-all-html ()
  "Export all subtrees that are *not* tagged with :noexport: to
separate files.

Note that subtrees must have the :EXPORT_FILE_NAME: property set
to a unique value for this to work properly."
 (interactive)
 (org-map-entries (lambda () (funcall 'org-html-export-to-html nil t)) "-noexport" 'region-start-level)
 )
#+END_SRC

** org-babel
Loads =org-babel= languages.

#+BEGIN_SRC emacs-lisp
(use-package ob-sagemath
  :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (require 'ob-C)
  (require 'ob-python)
  (org-babel-do-load-languages
   'org-babel-load-languages
    '( (ruby . t)
       (python . t)
       (haskell . t)
       (C . t)
       (emacs-lisp . t)
       (ditaa . t)
       (sagemath . t)
       (translate . t)
     ))
#+END_SRC

*** Sage
Org-babel-sage configuration:

#+BEGIN_SRC emacs-lisp
  ;; Ob-sagemath supports only evaluating with a session.
  (setq org-babel-default-header-args:sage '((:session . t)
                                             (:results . "output")))

  ;; C-c c for asynchronous evaluating (only for SageMath code blocks).
  (with-eval-after-load "org"
    (define-key org-mode-map (kbd "C-c c") 'ob-sagemath-execute-async))

  ;; Do not confirm before evaluation
  (setq org-confirm-babel-evaluate nil)

  ;; Do not evaluate code blocks when exporting.
  (setq org-export-babel-evaluate nil)

  ;; Show images when opening a file.
  (setq org-startup-with-inline-images t)

  ;; Show images after evaluating code blocks.
  (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
#+END_SRC

*** Haskell
Uses =runhaskell= when it outputs the results. Taken from
a great [[http://quickhack.net/nom/blog/2012-08-31-org-babel-and-haskell.html][article]] (in Japanese!) by Yoshinari Nomura.

#+BEGIN_SRC emacs-lisp
      (defadvice org-babel-haskell-initiate-session
        (around org-babel-haskell-initiate-session-advice)
        (let* ((buff (get-buffer "*haskell*"))
               (proc (if buff (get-buffer-process buff)))
               (type (cdr (assoc :result-type 'params)))
               (haskell-program-name
                (if (equal type 'output) "runhaskell-ob" "ghci")))
          (if proc (kill-process proc))
          (sit-for 0)
          (if buff (kill-buffer buff))
          ad-do-it))

      (ad-activate 'org-babel-haskell-initiate-session)
#+END_SRC

*** Ditaa
Path to Ditaa
#+BEGIN_SRC emacs-lisp
  (setq org-ditaa-jar-path "/usr/share/java/ditaa/ditaa-0_9.jar")
#+END_SRC
** org-capture
#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)

  (defadvice org-capture
    (after make-full-window-frame activate)
    "Advise capture to be the only window when used as a popup"
    (if (equal "emacs-capture" (frame-parameter nil 'name))
      (delete-other-windows)))

  (add-hook 'org-capture-mode-hook 'delete-other-windows)
  (add-hook 'org-capture-after-finalize-hook 'delete-frame)

  (setq org-capture-templates
	(quote (
		("x" "org-protocol" entry (file+headline m42/links-file "Inbox")
		 "** %c %?" :kill-buffer t :prepend t)
		("i" "idea" entry (file+olp m42/ideas-file "Inbox")
		 "*** %?\n%U\n" :kill-buffer t :prepend t)
		("b" "bug" entry (file+olp m42/bugs-file "Inbox")
		 "** %?\n%U\n" :kill-buffer t :prepend t)
		("t" "task" entry (file+olp m42/agenda-file "Inbox")
		 "** %?\n%U\n" :kill-buffer t :prepend t)
            ("v" "vocabulary" entry (file+olp "~/org/wiki/english.org" "Vocabulary")
		 "** %?\n" :kill-buffer t :prepend t)
            ("m" "math-drill cards")
            ("mc" "category theory" entry (file+olp m42/math-drill-file "Category theory")
             "** %? :drill:\n" :kill-buffer t :prepend t)
            ("ma" "algebra" entry (file+olp m42/math-drill-file "Algebra")
             "** %? :drill:\n" :kill-buffer t :prepend t)
            ("mn" "analysis" entry (file+olp m42/math-drill-file "Analysis")
             "** %? :drill:\n" :kill-buffer t :prepend t)
            ("mt" "topology" entry (file+olp m42/math-drill-file "Topology")
             "** %? :drill:\n" :kill-buffer t :prepend t)
            ("mo" "other" entry (file+olp m42/math-drill-file "Other")
             "** %? :drill:\n" :kill-buffer t :prepend t)
	       )))
#+END_SRC

** org-wiki
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/org-wiki")
(require 'org-wiki)
(setq org-wiki-location "~/org/wiki")
#+END_SRC

** org-gcal
Initial configuration, using the Google API. Follows [[https://cestlaz.github.io/posts/using-emacs-26-gcal/#.WNpulq2xVhE][this tutorial by C'est la Z]].

#+BEGIN_SRC emacs-lisp
(use-package org-gcal
  :ensure t
  :config
  (setq org-gcal-client-id "139081640689-4njrqlrlidldfo9j0s8vp20qrgvbr06g.apps.googleusercontent.com"
	org-gcal-client-secret m42/gcal-client-secret
	org-gcal-file-alist '(("mromang08@gmail.com" . "~/org/wiki/calendar.org"))))
#+END_SRC

Hooks for synchronization.

#+BEGIN_SRC emacs-lisp
(add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync)))
(add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-sync)))
#+END_SRC

*** DISABLED calfw
#+BEGIN_SRC emacs-lisp
  ;; (use-package calfw
  ;;   :ensure
  ;;   :config
  ;;   (require 'calfw) 
  ;;   (require 'calfw-org)
  ;;   (setq cfw:org-overwrite-default-keybinding t)
  ;;   (require 'calfw-ical)

  ;;   (defun mycalendar ()
  ;;     (interactive)
  ;;     (cfw:open-calendar-buffer
  ;;      :contents-sources
  ;;      (list
  ;;       (cfw:org-create-source "Green")  ; orgmode source
  ;;       ;(cfw:ical-create-source "gcal" "https://somecalnedaraddress" "IndianRed")
  ;;       ;(cfw:ical-create-source "gcal" "https://anothercalendaraddress" "IndianRed")
  ;;       ))) 
  ;;   (setq cfw:org-overwrite-default-keybinding t))

  ;; (use-package calfw-gcal
  ;; 	:ensure t
  ;; 	:config
  ;; 	(require 'calfw-gcal))
#+END_SRC

** Tasks & To-read
Following the advice of [[https://rafaelleru.github.io/2017/01/22/to_read_list_emacs/][@rafaelleru]].

#+BEGIN_SRC emacs-lisp
  (defun m42/export-html-if-agenda()
    "Auto exports an html file"
    (when (equal buffer-file-name m42/links-file)
      (org-twbs-export-to-html)))

  (add-hook 'after-save-hook 'm42/export-html-if-agenda)
#+END_SRC

** org-latex
Uses =C-ñ= to preview formulas:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-ñ") 'org-toggle-latex-fragment)
#+END_SRC

\[
e^{i\tau} = 1
\]

*** Default packages
#+BEGIN_SRC emacs-lisp
  ;; (setq org-latex-default-packages-alist
  ;;   (quote
  ;;     (("utf8x" "inputenc" t)
  ;;      ("T1" "fontenc" t)
  ;;      ("" "fixltx2e" nil)
  ;;      ("" "graphicx" t)
  ;;      ("" "grffile" t)
  ;;      ("" "longtable" nil)
  ;;      ("" "wrapfig" nil)
  ;;      ("" "rotating" nil)
  ;;      ("normalem" "ulem" t)
  ;;      ("" "amsmath" t)
  ;;      ("" "textcomp" t)
  ;;      ("" "amssymb" t)
  ;;      ("" "capt-of" nil)
  ;;      ("colorlinks=true" "hyperref" nil))))
#+END_SRC

*** Ignore headlines
#+BEGIN_SRC emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+END_SRC

*** scrbook
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("scrbook" "\\documentclass{scrbook}"
                 ("\\part{%s}" . "\\part*{%s}")
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}"))))
#+END_SRC

*** scrrept
#+BEGIN_SRC emacs-lisp
(with-eval-after-load "ox-latex"
  (add-to-list 'org-latex-classes
               '("scrreprt" "\\documentclass{scrreprt}"
                 ("\\part{%s}" . "\\part*{%s}")
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}"))))
#+END_SRC

*** minted
#+BEGIN_SRC emacs-lisp
(setq org-latex-listings 'minted
      org-latex-packages-alist '(("" "minted")))
(setq org-latex-minted-options
     '(("frame" "lines") 
       ))
#+END_SRC
*** cd-latex
#+BEGIN_SRC emacs-lisp
  (use-package cdlatex
    :ensure t)

  (add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+END_SRC

*** Latex math mode abbreviations
Abbreviations on =latex-math-mode=.

#+BEGIN_SRC emacs-lisp
  (setq LaTeX-math-abbrev-prefix "ç")
  (setq LaTeX-math-list
    (quote
      ((";" "mathbb{" "" nil)
       ("=" "cong" "" nil)
       ("<right>" "longrightarrow" "" nil)
       ("<left>" "longleftarrow" "" nil)
       ("C-<right>" "Longrightarrow" "" nil)
       ("C-<left>" "Longleftarrow" "" nil)
       ("^" "widehat" "" nil)
       ("~" "widetilde" "" nil)
       ("'" "\partial" "" nil)
       ("0" "varnothing" "" nil)
       ("C-(" "left(" "" nil)
       ("C-)" "right)" "" nil)
       )))
#+END_SRC

*** Latex math mode
Requires Latex to use =latex-math-mode=. It is activated by default.

#+BEGIN_SRC emacs-lisp
  (use-package tex
    :ensure auctex)
  (require 'latex)

  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
  (add-hook 'org-mode-hook 'LaTeX-math-mode)
#+END_SRC

*** Conmutative diagrams
Conmutative diagrams with the =tikz-cd= package.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-packages-alist '("" "tikz" t))
  (eval-after-load "preview"
    '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{tikzpicture}" t))
  (setq org-latex-create-formula-image-program 'imagemagick)
#+END_SRC

*** Zooming
Zooms latex image previews along with the text using =C-x C-+=.

#+BEGIN_SRC emacs-lisp
  (defun update-org-latex-fragment-scale ()
    (let ((text-scale-factor (expt text-scale-mode-step text-scale-mode-amount)))
      (plist-put org-format-latex-options :scale (* 1.2 text-scale-factor)))
  )
  (add-hook 'text-scale-mode-hook 'update-org-latex-fragment-scale)
#+END_SRC

** org-pinta
Creates an image using =imagemagick= and opens
a =pinta= window to edit it.

# It should be generalized to an editor-agnostic function,
# not using pinta, but the given editor.

#+BEGIN_SRC emacs-lisp
  (setq pinta-dir "./images/")
  (setq pinta-dimension "300x300")

  (defun org-pinta (filename)
    "Creates an image using pinta"
    (interactive "sImage name: ")

    (let ((file (concat pinta-dir "/" filename ".png")))
      ; creates the image, opens pinta
      (shell-command (concat "mkdir -p $(dirname " file ") && touch " file))
      (shell-command (concat "convert -size " pinta-dimension " xc:white png24:" file))
      (shell-command (concat "pinta " file))

      ; inserts the image in the current buffer
      (insert "#+begin_center")
      (newline)
      (insert "#+attr_latex: :width 50px")
      (newline)
      (insert (concat "[[" file "]]"))
      (newline)
      (insert "#+end_center")
    )
  )
#+END_SRC

#+begin_center
#+attr_latex: :width 50px
[[./pinta//painting.png]]
#+end_center
** org-pomodoro
#+BEGIN_SRC emacs-lisp
(use-package org-pomodoro
  :ensure t)
#+END_SRC
** org-checkboxes
#+BEGIN_SRC emacs-lisp
(setq org-checkbox-hierarchical-statistics t)
#+END_SRC
* Snippets
** Yasnippet support
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :init (add-to-list 'load-path "~/.emacs.d/plugins/yasnippet")
    :config (yas-global-mode 1)
    :bind (("<C-dead-grave>" . yas-insert-snippet))
    )
#+END_SRC

** Snippets for programming languages
#+BEGIN_SRC emacs-lisp
  (use-package haskell-snippets
    :ensure t)
#+END_SRC
** Yankpad
[[https://github.com/Kungsgeten/yankpad][Yankpad]] provides a simpler way of managing snippets within an
org-mode file. Snippets are stored in the =yankpad-file=, which
in my case is [[file:yankpad.org][this]] file.

 * Snippets can be inserted with =yankpad-insert=.
 * Current category of snippets can be set with =yankpad-capture=.
 * Snippets can be added to the current category using
   =yankpad-capture=.

#+BEGIN_SRC emacs-lisp
  (use-package yankpad
    :ensure t
    :defer 10
    :init (setq yankpad-file "~/.emacs.d/yankpad.org")
    :bind (("M-ñ" . yankpad-insert))
  )
#+END_SRC

* Blog
** org-page
I use =org-page= to generate [[https://m42.github.io/][my blog]]

#+BEGIN_SRC emacs-lisp
  (use-package org-page
    :ensure t)

  (setq op/repository-directory "~/projects/m42.github.io/")
  (setq op/site-domain "http://m42.github.io/")
  (setq op/site-main-title "Mario Román")
  (setq op/site-sub-title "M42 - mromang08@gmail.com")
  (setq op/personal-github-link "https://github.com/m42")
  (setq op/theme 'mdo_modified)
#+END_SRC

the blog sections are specified here

#+BEGIN_SRC emacs-lisp
(setq op/category-config-alist
   '(("blog" 
      :show-meta t 
      :show-comment nil 
      :uri-generator op/generate-uri 
      :uri-template "/blog/%y/%m/%d/%t/" 
      :sort-by :date 
      :category-index t)
     ("index"
      :show-meta nil 
      :show-comment nil 
      :uri-generator op/generate-uri 
      :uri-template "/" 
      :sort-by :date 
      :category-index nil)
     ("about"
      :show-meta nil 
      :show-comment nil 
      :uri-generator op/generate-uri 
      :uri-template "/about/" 
      :sort-by :date 
      :category-index nil)))
#+END_SRC
** hugo
A Hugo blogging solution based on [[http://www.holgerschurig.de/en/emacs-blog-from-org-to-hugo/][this post]].

#+BEGIN_SRC emacs-lisp
  (defvar hugo-content-dir "~/projects/blog/content/"
    "Path to Hugo's content directory")

  (defun hugo-ensure-property (property)
    "Make sure that a property exists. If not, it will be created.

  Returns the property name if the property has been created,
  otherwise nil."
    (if (org-entry-get nil property)
        nil
      (progn (org-entry-put nil property "")
             property)))

  (defun hugo-ensure-properties ()
    "This ensures that several properties exists. If not, these
  properties will be created in an empty form. In this case, the
  drawer will also be opened and the cursor will be positioned
  at the first element that needs to be filled.

  Returns list of properties that still must be filled in"
    (require 'dash)
    (let ((current-time (format-time-string (org-time-stamp-format t t) (org-current-time)))
          first)
      (save-excursion
        (unless (org-entry-get nil "TITLE")
          (org-entry-put nil "TITLE" (nth 4 (org-heading-components))))
        (setq first (--first it (mapcar #'hugo-ensure-property '("HUGO_TAGS" "HUGO_TOPICS" "HUGO_FILE"))))
        (unless (org-entry-get nil "HUGO_DATE")
          (org-entry-put nil "HUGO_DATE" current-time)))
      (when first
        (goto-char (org-entry-beginning-position))
        ;; The following opens the drawer
        (forward-line 1)
        (beginning-of-line 1)
        (when (looking-at org-drawer-regexp)
          (org-flag-drawer nil))
        ;; And now move to the drawer property
        (search-forward (concat ":" first ":"))
        (end-of-line))
      first))

  (defun hugo ()
    (interactive)
    (unless (hugo-ensure-properties)
      (let* ((title    (concat "title = \"" (org-entry-get nil "TITLE") "\"\n"))
             (date     (concat "date = \"" (format-time-string "%Y-%m-%d" (apply 'encode-time (org-parse-time-string (org-entry-get nil "HUGO_DATE"))) t) "\"\n"))
             (topics   (concat "topics = [ \"" (mapconcat 'identity (split-string (org-entry-get nil "HUGO_TOPICS") "\\( *, *\\)" t) "\", \"") "\" ]\n"))
             (tags     (concat "tags = [ \"" (mapconcat 'identity (split-string (org-entry-get nil "HUGO_TAGS") "\\( *, *\\)" t) "\", \"") "\" ]\n"))
             (fm (concat "+++\n"
                         title
                         date
                         tags
                         topics
                         "+++\n\n"))
             (file     (org-entry-get nil "HUGO_FILE"))
             (coding-system-for-write buffer-file-coding-system)
             (backend  'md)
             (blog))
        ;; try to load org-mode/contrib/lisp/ox-gfm.el and use it as backend
        (if (require 'ox-gfm nil t)
            (setq backend 'gfm)
          (require 'ox-md))
        (setq blog (org-export-as backend t))
        ;; Normalize save file path
        (unless (string-match "^[/~]" file)
          (setq file (concat hugo-content-dir file))
        (unless (string-match "\\.md$" file)
          (setq file (concat file ".md")))
        ;; save markdown
        (with-temp-buffer
          (insert fm)
          (insert blog)
          ;; mathjax
          (save-excursion 
            (goto-char (point-min)) (replace-string "\\\(" "\\\\\(")
            (goto-char (point-min)) (replace-string "\\\)" "\\\\\)")
            (goto-char (point-min)) (replace-string "\\\[" "\\\\\[")
            (goto-char (point-min)) (replace-string "\\\]" "\\\\\]")
            )

          (untabify (point-min) (point-max))
          (write-file file)
          (message "Exported to %s" file))
        ))))

  (bind-key "M-g h" #'hugo)
#+END_SRC

*** ox-gfm
#+BEGIN_SRC emacs-lisp
(use-package ox-gfm
  :ensure t)

(eval-after-load "org"
  '(require 'ox-gfm nil t))
#+END_SRC

* Social
** Mastodon
[[https://en.wikipedia.org/wiki/Mastodon_(software)][Mastodon]] is a free software federated social network. A specific
[[https://github.com/jdenen/mastodon.el][mastodon-mode]] was written by Johnson Denen (@jdenen).

#+BEGIN_SRC emacs-lisp
(use-package mastodon
  :config (setq mastodon-instance-url "https://mastodon.social")
  :ensure t)
#+END_SRC

* Other packages


** Engine-mode
[[https://github.com/hrs/engine-mode][Engine mode]] allows us to use a search engine directly on Emacs. It binds the different 
search engines to =C-x / ?=, where =?= is a char representing the engine.

#+BEGIN_SRC emacs-lisp
(use-package engine-mode
  :ensure t)

(defengine duckduckgo
  "https://duckduckgo.com/?q=%s"
  :keybinding "d")
(defengine github
  "https://github.com/search?ref=simplesearch&q=%s"
  :keybinding "g")
(defengine google
  "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")
(defengine rfcs
  "http://pretty-rfc.herokuapp.com/search?q=%s")
(defengine stack-overflow
  "https://stackoverflow.com/search?q=%s"
  :keybinding "s")
(defengine wikipedia
  "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
  :keybinding "w")
(defengine wiktionary
  "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

(engine-mode t)
#+END_SRC

** Stackoverflow
#+BEGIN_SRC emacs-lisp
(use-package sx
  :ensure t
  :config
  (bind-keys :prefix "C-c s"
             :prefix-map my-sx-map
             :prefix-docstring "Global keymap for SX."
             ("q" . sx-tab-all-questions)
             ("i" . sx-inbox)
             ("o" . sx-open-link)
             ("u" . sx-tab-unanswered-my-tags)
             ("a" . sx-ask)
             ("s" . sx-search)))
#+END_SRC

** DISABLED dict-replace
My dict-replace package. I am no longer using it.

#+BEGIN_SRC emacs-lisp
  ;(load-file "~/.emacs.d/dict-replace.el")
  ;(global-set-key (kbd "<f5>") 'dict-translate)
#+END_SRC
